(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{325:function(e,t,s){"use strict";s.r(t);var r=s(0),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"promise"}},[e._v("Promise")]),s("h2",{attrs:{id:"promise-a"}},[e._v("Promise/A+")]),s("p",[e._v("首先我们要知道自己手写一个"),s("code",[e._v("Promise")]),e._v("，应该怎么去写，谁来告诉我们怎么写，需要遵循什么样的规则。当然这些你都不用担心，其实业界都是通过一个规则指标来生产"),s("code",[e._v("Promise")]),e._v("的。让我们来看看是什么东西。传送门☞"),s("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+"),s("OutboundLink")],1)]),s("h2",{attrs:{id:"constructor"}},[e._v("constructor")]),s("p",[e._v("我们先声明一个类，叫做"),s("code",[e._v("Promise")]),e._v("，里面是构造函数。如果es6还有问题的可以去阮大大的博客上学习一下（传送门☞"),s("a",{attrs:{href:"http://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("es6"),s("OutboundLink")],1),e._v("）")]),e._m(0),s("p",[e._v("那么接下来我会分析上面代码的作用，原理")]),e._m(1),s("h2",{attrs:{id:"then"}},[e._v("then")]),e._m(2),e._m(3),e._m(4),s("h2",{attrs:{id:"异步的promise"}},[e._v("异步的Promise")]),s("p",[e._v("之前我们只是处理了同步情况下的Promise，简而言之所有操作都没有异步的成分在内。那么如果是异步该怎么办？")]),s("h3",{attrs:{id:"_1-callback"}},[e._v("1.callback")]),e._m(5),s("p",[e._v("首先我们需要改一下构造器里的代码，分别添加两个回调函数的数组，分别对应成功回调和失败回调。他们的作用是当成功执行resolve或reject时，执行callback。")]),e._m(6),s("p",[e._v("然后是then需要多加一个状态判断，当Promise中是异步操作时，需要在我们之前定义的回调函数数组中添加一个回调函数。")]),e._m(7),s("h3",{attrs:{id:"_2-resolvepromise"}},[e._v("2.resolvePromise")]),e._m(8),e._m(9),s("p",[e._v("一下子多了很多方法，不用怕，我会一一解释")]),s("ol",[e._m(10),e._m(11),s("li",[e._v("为什么开头有两个判断？：这就是之前想要解决的如果then函数中的参数不是函数，那么我们需要做处理。如果onFufilled不是函数，就需要自定义个函数用来返回之前resolve的值，如果onRejected不是函数，自定义个函数抛出异常。这里会有个小坑，如果这里不抛出异常，会在下一个then的onFufilled中拿到值。又因为这里抛出了异常所以所有的onFufilled或者onRejected都需要try/catch，这也是"),s("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+"),s("OutboundLink")],1),e._v("的规范。当然本人觉得成功的回调不需要抛出异常也可以，大家可以仔细想想。")]),s("li",[s("code",[e._v("resolvePromise")]),e._v("是什么？：这其实是官方"),s("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+"),s("OutboundLink")],1),e._v("的需求。因为你的then可以返回任何职，当然包括"),s("code",[e._v("Promise")]),e._v("对象，而如果是"),s("code",[e._v("Promise")]),e._v("对象，我们就需要将他拆解，直到它不是一个"),s("code",[e._v("Promise")]),e._v("对象，取其中的值。")])]),e._m(12),e._m(13),e._m(14),s("ol",[e._m(15),s("li",[e._v("为什么要在一开始判断"),s("code",[e._v("promise2")]),e._v("和"),s("code",[e._v("x")]),e._v("？：首先在"),s("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+"),s("OutboundLink")],1),e._v("中写了需要判断这两者如果相等，需要抛出异常，我就来解释一下为什么，如果这两者相等，我们可以看下下面的例子，第一次p2是p1.then出来的结果是个"),s("code",[e._v("Promise")]),e._v("对象，这个"),s("code",[e._v("Promise")]),e._v("对象在被创建的时候调用了resolvePromise(promise2,x,resolve,reject)函数，又因为x等于其本身，是个"),s("code",[e._v("Promise")]),e._v("，就需要then方法递归它，直到他不是"),s("code",[e._v("Promise")]),e._v("对象，但是x（p2）的结果还在等待，他却想执行自己的then方法，就会导致等待。")])]),e._m(16),s("ol",[e._m(17),s("li",[e._v("为什么取then这个属性？：因为我们需要去判断x是否为Promise，then属性如果为普通值，就直接resolve掉，如果是个function，就是Promise对象，之后我们就需要将这个x的then方法进行执行，用call的原因是因为then方法里面this指向的问题。")]),s("li",[e._v("为什么要递归去调用"),s("code",[e._v("resolvePromise")]),e._v("函数？：相信细心的人已经发现了，我这里使用了递归调用法，首先这是"),s("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+"),s("OutboundLink")],1),e._v("中要求的，其次是业务场景的需求，当我们碰到那种Promise的resolve里的Promise的resolve里又包了一个Promise的话，就需要递归取值，直到x不是Promise对象。")])]),s("h2",{attrs:{id:"完善promise"}},[e._v("完善Promise")]),e._m(18),s("h3",{attrs:{id:"catch"}},[e._v("catch")]),s("p",[e._v("相信大家都知道catch这个方法是用来捕获Promise中的reject的值，也就是相当于then方法中的onRejected回调函数，那么问题就解决了。我们来看代码。")]),e._m(19),e._m(20),s("h3",{attrs:{id:"resolve-reject"}},[e._v("resolve/reject")]),e._m(21),e._m(22),e._m(23),s("h3",{attrs:{id:"all"}},[e._v("all")]),s("p",[e._v("all方法可以说是Promise中很常用的方法了，它的作用就是将一个数组的Promise对象放在其中，当全部resolve的时候就会执行then方法，当有一个reject的时候就会执行catch，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。")]),e._m(24),e._m(25),s("h3",{attrs:{id:"race"}},[e._v("race")]),e._m(26),e._m(27),e._m(28),s("h3",{attrs:{id:"promise语法糖-deferred"}},[e._v("Promise语法糖 deferred")]),s("p",[e._v("语法糖这三个字大家一定很熟悉，作为一个很Swag的前端工程师，对async/await这对兄弟肯定很熟悉，没错他们就是generator的语法糖。而我们这里要讲的语法糖是Promise的。")]),e._m(29),s("p",[e._v("什么作用呢？看下面代码你就知道了")]),e._m(30),e._m(31)])}),[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("class Promise{\n  constructor(executor){\n    //控制状态，使用了一次之后，接下来的都不被使用\n    this.status = 'pendding'\n    this.value = undefined\n    this.reason = undefined\n    \n    //定义resolve函数\n    let resolve = (data)=>{\n      //这里pendding，主要是为了防止executor中调用了两次resovle或reject方法，而我们只调用一次\n      if(this.status==='pendding'){\n        this.status = 'resolve'\n        this.value = data\n      } \n    }\n\n    //定义reject函数\n    let reject = (data)=>{\n      if(this.status==='pendding'){\n        this.status = 'reject'        \n        this.reason = data\n      } \n    }\n\n    //executor方法可能会抛出异常，需要捕获\n    try{\n      //将resolve和reject函数给使用者      \n      executor(resolve,reject)      \n    }catch(e){\n      //如果在函数中抛出异常则将它注入reject中\n      reject(e)\n    }\n  }\n}\n复制代码\n")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[s("code",[e._v("executor：")]),e._v("这是实例"),s("code",[e._v("Promise")]),e._v("对象时在构造器中传入的参数，一般是一个"),s("code",[e._v("function(resolve,reject){}")])]),s("li",[s("code",[e._v("status：``Promise")]),e._v("的状态，一开始是默认的pendding状态，每当调用道resolve和reject方法时，就会改变其值，在后面的then方法中会用到")]),s("li",[s("code",[e._v("value：")]),e._v("resolve回调成功后，调用resolve方法里面的参数值")]),s("li",[s("code",[e._v("reason：")]),e._v("reject回调成功后，调用reject方法里面的参数值")]),s("li",[s("code",[e._v("resolve：")]),e._v("声明resolve方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调")]),s("li",[s("code",[e._v("reject：")]),e._v("声明reject方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("then方法是"),t("code",[this._v("Promise")]),this._v("中最为重要的方法，他的用法大家都应该已经知道，就是将"),t("code",[this._v("Promise")]),this._v("中的resolve或者reject的结果拿到，那么我们就能知道这里的then方法需要两个参数，成功回调和失败回调，上代码！")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("then(onFufilled,onRejected){  \n  if(this.status === 'resolve'){\n    onFufilled(this.value)\n  }\n  if(this.status === 'reject'){\n    onRejected(this.reason)\n  }\n}\n复制代码\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("这里主要做了将构造器中resolve和reject的结果传入"),t("code",[this._v("onFufilled")]),this._v("和"),t("code",[this._v("onRejected")]),this._v("中，注意这两个是使用者传入的参数，是个方法。所以你以为这么简单就完了？要想更"),t("code",[this._v("Swag")]),this._v("的应对各种场景，我们必须得再完善。继续往下走！")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("最早处理异步的方法就是callback，就相当于我让你帮我扫地，我会在给你发起任务时给你一个手机，之后我做自己的事情去，不用等你，等你扫完地就会打手机给我，诶，我就知道了地扫完了。这个手机就是callback，回调函数。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("//存放成功回调的函数\nthis.onResolvedCallbacks = []\n//存放失败回调的函数\nthis.onRejectedCallbacks = []\n\nlet resolve = (data)=>{\n  if(this.status==='pendding'){\n    this.status = 'resolve'\n    this.value = data\n    //监听回调函数\n    this.onResolvedCallbacks.forEach(fn=>fn())\n  } \n}\nlet reject = (data)=>{\n  if(this.status==='pendding'){\n    this.status = 'reject'        \n    this.reason = data\n    this.onRejectedCallbacks.forEach(fn=>fn())\n  } \n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("if(this.status === 'pendding'){\n  this.onResolvedCallbacks.push(()=>{\n    // to do....\n    let x = onFufilled(this.value)\n    resolvePromise(promise2,x,resolve,reject)\n  })\n  this.onRejectedCallbacks.push(()=>{\n    let x = onRejected(this.reason)\n    resolvePromise(promise2,x,resolve,reject)\n  })\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("这也是"),t("code",[this._v("Promise")]),this._v("中的重头戏，我来介绍一下，我们在用Promise的时候可能会发现，当then函数中return了一个值，我们可以继续then下去，不过是什么值，都能在下一个then中获取，还有，当我们不在then中放入参数，例："),t("code",[this._v("promise.then().then()")]),this._v("，那么其后面的then依旧可以得到之前then返回的值，可能你现在想很迷惑。让我来解开你心中的忧愁，"),t("strong",[this._v("follow me")]),this._v("。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("then(onFufilled,onRejected){ \n    //解决onFufilled,onRejected没有传值的问题\n    onFufilled = typeof onFufilled === 'function'?onFufilled:y=>y\n    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后then的resolve中捕获\n    onRejected = typeof onRejected === 'function'?onRejected:err=>{ throw err ;}\n    //声明一个promise对象\n    let promise2\n    if(this.status === 'resolve'){\n      //因为在.then之后又是一个promise对象，所以这里肯定要返回一个promise对象\n      promise2 = new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n          //因为穿透值的缘故，在默认的跑出一个error后，不能再用下一个的reject来接受，只能通过try，catch        \n          try{\n            //因为有的时候需要判断then中的方法是否返回一个promise对象，所以需要判断\n            //如果返回值为promise对象，则需要取出结果当作promise2的resolve结果\n            //如果不是，直接作为promise2的resolve结果\n            let x = onFufilled(this.value)\n            //抽离出一个公共方法来判断他们是否为promise对象\n            resolvePromise(promise2,x,resolve,reject)\n          }catch(e){\n            reject(e)\n          }\n        },0)\n      })\n    }\n    if(this.status === 'reject'){\n      promise2 = new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n          try{\n            let x = onRejected(this.reason)\n            resolvePromise(promise2,x,resolve,reject)\n          }catch(e){\n            reject(e)\n          }\n        },0)\n      })\n    }\n    if(this.status === 'pendding'){\n      promise2 = new Promise((resolve,reject)=>{\n        this.onResolvedCallbacks.push(()=>{\n          // to do....\n          setTimeout(()=>{\n            try{\n              let x = onFufilled(this.value)\n              resolvePromise(promise2,x,resolve,reject)\n            }catch(e){\n              reject(e)\n            }\n          },0)\n        })\n        this.onRejectedCallbacks.push(()=>{\n          setTimeout(()=>{\n            try{\n              let x = onRejected(this.reason)\n              resolvePromise(promise2,x,resolve,reject)\n            }catch(e){\n              reject(e)\n            }\n          })\n        })\n      })\n    }\n    return promise2\n  }\n复制代码\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[this._v("返回"),t("code",[this._v("Promise")]),this._v("？：首先我们要注意的一点是，then有返回值，then了之后还能在then，那就说明之前的then返回的必然是个"),t("code",[this._v("Promise")]),this._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[this._v("为什么外面要包一层"),t("code",[this._v("setTimeout")]),this._v("？：因为Promise本身是一个异步方法，属于微任务一列，必须得在执行栈执行完了在去取他的值，所以所有的返回值都得包一层异步setTimeout。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("那就让我们来看看这个"),t("code",[this._v("resolvePromise")]),this._v("到底长啥样。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("function resolvePromise(promise2,x,resolve,reject){\n  //判断x和promise2之间的关系\n  //因为promise2是上一个promise.then后的返回结果，所以如果相同，会导致下面的.then会是同一个promise2，一直都是，没有尽头\n  if(x === promise2){//相当于promise.then之后return了自己，因为then会等待return后的promise，导致自己等待自己，一直处于等待\n    return reject(new TypeError('循环引用'))\n  }\n  //如果x不是null，是对象或者方法\n  if(x !== null && (typeof x === 'object' || typeof x === 'function')){\n    //为了判断resolve过的就不用再reject了，（比如有reject和resolve的时候）\n    let called\n    try{//防止then出现异常，Object.defineProperty\n      let then = x.then//取x的then方法可能会取到{then:{}},并没有执行\n      if(typeof then === 'function'){\n        //我们就认为他是promise,call他,因为then方法中的this来自自己的promise对象\n        then.call(x,y=>{//第一个参数是将x这个promise方法作为this指向，后两个参数分别为成功失败回调\n          if(called) return;\n          called = true\n          //因为可能promise中还有promise，所以需要递归\n          resolvePromise(promise2,y,resolve,reject)\n        },err=>{\n          if(called) return;\n          called = true\n          //一次错误就直接返回\n          reject(err)\n        })\n      }else{\n        //如果是个普通对象就直接返回resolve作为结果\n        resolve(x)\n      }\n    }catch(e){\n      if(called) return;\n      called = true\n      reject(e)\n    }\n  }else{\n    //这里返回的是非函数，非对象的值,就直接放在promise2的resolve中作为结果\n    resolve(x)\n  }\n}\n复制代码\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("它的作用是用来将onFufilled的返回值进行判断取值处理，把最后获得的值放入最外面那层的"),t("code",[this._v("Promise")]),this._v("的resolve函数中。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[this._v("参数"),t("code",[this._v("promise2")]),this._v("（then函数返回的Promise对象），"),t("code",[this._v("x")]),this._v("（onFufilled函数的返回值），"),t("code",[this._v("resolve、reject")]),this._v("（最外层的Promise上的resolve和reject）。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let p1 = new Promise((resolve,reject)=>{\n  resolve()\n})\n\nlet p2 = p1.then(d=>{\n    return p2\n})\n复制代码\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[this._v("called是用来干嘛的？：called变量主要是用来判断如果"),t("code",[this._v("resolvePromise")]),this._v("函数已经resolve或者reject了，那就不需要在执行下面的resolce或者reject。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("我们现在已经基本完成了Promise的then方法，那么现在我们需要看看他的其他方法。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("//catch方法\ncatch(onRejected){\n  return this.then(null,onRejected)\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("该方法是挂在Promise原型上的方法。当我们调用catch传callback的时候，就相当于是调用了then方法。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("大家一定都看到过"),t("code",[this._v("Promise.resolve()、Promise.reject()")]),this._v("这两种用法，它们的作用其实就是返回一个Promise对象，我们来实现一下。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("//resolve方法\nPromise.resolve = function(val){\n  return new Promise((resolve,reject)=>{\n    resolve(val)\n  })\n}\n//reject方法\nPromise.reject = function(val){\n  return new Promise((resolve,reject)=>{\n    reject(val)\n  })\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("这两个方法是直接可以通过class调用的，原理就是返回一个内部是resolve或reject的Promise对象。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)\nPromise.all = function(promises){\n  let arr = []\n  let i = 0\n  function processData(index,data){\n    arr[index] = data\n    i++\n    if(i == promises.length){\n      resolve(arr)\n    }\n  }\n  return new Promise((resolve,reject)=>{\n    for(let i=0;i<promises.length;i++){\n      promises[i].then(data=>{\n        processData(i,data)\n      },reject)\n    }\n  })\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("其原理就是将参数中的数组取出遍历，每当执行成功都会执行"),t("code",[this._v("processData")]),this._v("方法，"),t("code",[this._v("processData")]),this._v("方法就是用来记录每个Promise的值和它对应的下标，当执行的次数等于数组长度时就会执行resolve，把arr的值给then。这里会有一个坑，如果你是通过arr数组的长度来判断他是否应该resolve的话就会出错，为什么呢？因为js数组的特性，导致如果先出来的是1位置上的值进arr，那么0位置上也会多一个空的值，所以不合理。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("race方法虽然不常用，但是在Promise方法中也是一个能用得上的方法，它的作用是将一个"),t("code",[this._v("Promise")]),this._v("数组放入race中，哪个先执行完，race就直接执行完，并从then中取值。我们来实现一下吧。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("//race方法\nPromise.race = function(promises){\n  return new Promise((resolve,reject)=>{\n    for(let i=0;i<promises.length;i++){\n      promises[i].then(resolve,reject)\n    }\n  })\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("原理大家应该看懂了，很简单，就是遍历数组执行Promise，如果有一个"),t("code",[this._v("Promise")]),this._v("执行成功就resolve。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("//promise语法糖 也用来测试\nPromise.deferred = Promise.defer = function(){\n  let dfd = {}\n  dfd.promise = new Promise((resolve,reject)=>{\n    dfd.resolve = resolve\n    dfd.reject = reject\n  })\n  return dfd\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let fs = require('fs')\nlet Promise = require('./promises')\n//Promise上的语法糖，为了防止嵌套，方便调用\n//坏处 错误处理不方便\nfunction read(){\n  let defer = Promise.defer()\n  fs.readFile('./1.txt','utf8',(err,data)=>{\n    if(err)defer.reject(err)\n    defer.resolve(data)\n  })\n  return defer.Promise\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("没错，我们可以方便的去调用他语法糖defer中的"),t("code",[this._v("Promise")]),this._v("对象。那么它还有没有另外的方法呢？答案是有的。我们需要在全局上安装promises-aplus-tests插件"),t("code",[this._v("npm i promises-aplus-tests -g")]),this._v("，再输入promises-aplus-tests [js文件名] 即可验证你的Promise的规范。")])])}],!1,null,null,null);t.default=n.exports}}]);