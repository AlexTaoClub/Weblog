<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 概念 | AlexTao 的 博客</title>
    <meta name="description" content="In doing we learn.">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/Weblog/assets/css/styles.bc17a3fe.css" as="style"><link rel="preload" href="/Weblog/assets/js/app.bc17a3fe.js" as="script"><link rel="preload" href="/Weblog/assets/js/72.c2fad7bd.js" as="script"><link rel="prefetch" href="/Weblog/assets/css/16.styles.2339a627.css"><link rel="prefetch" href="/Weblog/assets/css/5.styles.c1152841.css"><link rel="prefetch" href="/Weblog/assets/css/7.styles.1f4a6057.css"><link rel="prefetch" href="/Weblog/assets/css/8.styles.5b6e1357.css"><link rel="prefetch" href="/Weblog/assets/js/0.a8dcd889.js"><link rel="prefetch" href="/Weblog/assets/js/10.bbae2931.js"><link rel="prefetch" href="/Weblog/assets/js/100.b8573d34.js"><link rel="prefetch" href="/Weblog/assets/js/101.abec8cfc.js"><link rel="prefetch" href="/Weblog/assets/js/102.79aa7798.js"><link rel="prefetch" href="/Weblog/assets/js/11.249c3d32.js"><link rel="prefetch" href="/Weblog/assets/js/12.6c4f9a9d.js"><link rel="prefetch" href="/Weblog/assets/js/13.9c3a7225.js"><link rel="prefetch" href="/Weblog/assets/js/14.8788763f.js"><link rel="prefetch" href="/Weblog/assets/js/15.c3d91b4b.js"><link rel="prefetch" href="/Weblog/assets/js/16.2339a627.js"><link rel="prefetch" href="/Weblog/assets/js/17.f68b5694.js"><link rel="prefetch" href="/Weblog/assets/js/18.1dc877c8.js"><link rel="prefetch" href="/Weblog/assets/js/19.8d3a8eb9.js"><link rel="prefetch" href="/Weblog/assets/js/2.adb0855b.js"><link rel="prefetch" href="/Weblog/assets/js/20.5b430c8f.js"><link rel="prefetch" href="/Weblog/assets/js/21.7570ba60.js"><link rel="prefetch" href="/Weblog/assets/js/22.c34e9396.js"><link rel="prefetch" href="/Weblog/assets/js/23.d89c70ce.js"><link rel="prefetch" href="/Weblog/assets/js/24.cc87bb5d.js"><link rel="prefetch" href="/Weblog/assets/js/25.024b7a56.js"><link rel="prefetch" href="/Weblog/assets/js/26.0d0e2118.js"><link rel="prefetch" href="/Weblog/assets/js/27.fd65c2c2.js"><link rel="prefetch" href="/Weblog/assets/js/28.e7e81b37.js"><link rel="prefetch" href="/Weblog/assets/js/29.d69a29c6.js"><link rel="prefetch" href="/Weblog/assets/js/3.9c9ae281.js"><link rel="prefetch" href="/Weblog/assets/js/30.e02a9f2a.js"><link rel="prefetch" href="/Weblog/assets/js/31.4d5d63f6.js"><link rel="prefetch" href="/Weblog/assets/js/32.2652c4b5.js"><link rel="prefetch" href="/Weblog/assets/js/33.f81118fb.js"><link rel="prefetch" href="/Weblog/assets/js/34.6539d2a9.js"><link rel="prefetch" href="/Weblog/assets/js/35.479b4b73.js"><link rel="prefetch" href="/Weblog/assets/js/36.24e9784f.js"><link rel="prefetch" href="/Weblog/assets/js/37.13a7e720.js"><link rel="prefetch" href="/Weblog/assets/js/38.57e7625b.js"><link rel="prefetch" href="/Weblog/assets/js/39.40ddc61b.js"><link rel="prefetch" href="/Weblog/assets/js/4.cb1adf5e.js"><link rel="prefetch" href="/Weblog/assets/js/40.4abade23.js"><link rel="prefetch" href="/Weblog/assets/js/41.03a22716.js"><link rel="prefetch" href="/Weblog/assets/js/42.4bf6acac.js"><link rel="prefetch" href="/Weblog/assets/js/43.7d75114c.js"><link rel="prefetch" href="/Weblog/assets/js/44.a74a0979.js"><link rel="prefetch" href="/Weblog/assets/js/45.224f0ae1.js"><link rel="prefetch" href="/Weblog/assets/js/46.716c0ee0.js"><link rel="prefetch" href="/Weblog/assets/js/47.a44c77ff.js"><link rel="prefetch" href="/Weblog/assets/js/48.c92bc6c3.js"><link rel="prefetch" href="/Weblog/assets/js/49.78d85a96.js"><link rel="prefetch" href="/Weblog/assets/js/5.c1152841.js"><link rel="prefetch" href="/Weblog/assets/js/50.65d4cc82.js"><link rel="prefetch" href="/Weblog/assets/js/51.dfe21a00.js"><link rel="prefetch" href="/Weblog/assets/js/52.a55d1d66.js"><link rel="prefetch" href="/Weblog/assets/js/53.24e5ba30.js"><link rel="prefetch" href="/Weblog/assets/js/54.3d44c9e1.js"><link rel="prefetch" href="/Weblog/assets/js/55.5509d3c1.js"><link rel="prefetch" href="/Weblog/assets/js/56.389f0044.js"><link rel="prefetch" href="/Weblog/assets/js/57.a6410cdf.js"><link rel="prefetch" href="/Weblog/assets/js/58.99de433a.js"><link rel="prefetch" href="/Weblog/assets/js/59.f362327e.js"><link rel="prefetch" href="/Weblog/assets/js/6.829d0e7e.js"><link rel="prefetch" href="/Weblog/assets/js/60.d8a731fd.js"><link rel="prefetch" href="/Weblog/assets/js/61.c32405a4.js"><link rel="prefetch" href="/Weblog/assets/js/62.2cf15697.js"><link rel="prefetch" href="/Weblog/assets/js/63.97976992.js"><link rel="prefetch" href="/Weblog/assets/js/64.df2f0acc.js"><link rel="prefetch" href="/Weblog/assets/js/65.0365fc24.js"><link rel="prefetch" href="/Weblog/assets/js/66.89f67105.js"><link rel="prefetch" href="/Weblog/assets/js/67.4d546178.js"><link rel="prefetch" href="/Weblog/assets/js/68.b3742591.js"><link rel="prefetch" href="/Weblog/assets/js/69.e2c032ec.js"><link rel="prefetch" href="/Weblog/assets/js/7.1f4a6057.js"><link rel="prefetch" href="/Weblog/assets/js/70.f262dfb0.js"><link rel="prefetch" href="/Weblog/assets/js/71.24d5a255.js"><link rel="prefetch" href="/Weblog/assets/js/73.e3de86c7.js"><link rel="prefetch" href="/Weblog/assets/js/74.af039d36.js"><link rel="prefetch" href="/Weblog/assets/js/75.b5d26a4d.js"><link rel="prefetch" href="/Weblog/assets/js/76.5253b8d4.js"><link rel="prefetch" href="/Weblog/assets/js/77.13049fae.js"><link rel="prefetch" href="/Weblog/assets/js/78.732e7950.js"><link rel="prefetch" href="/Weblog/assets/js/79.91a95405.js"><link rel="prefetch" href="/Weblog/assets/js/8.5b6e1357.js"><link rel="prefetch" href="/Weblog/assets/js/80.60b08cac.js"><link rel="prefetch" href="/Weblog/assets/js/81.09852d19.js"><link rel="prefetch" href="/Weblog/assets/js/82.49b521d3.js"><link rel="prefetch" href="/Weblog/assets/js/83.681a706a.js"><link rel="prefetch" href="/Weblog/assets/js/84.ca93e702.js"><link rel="prefetch" href="/Weblog/assets/js/85.9813d878.js"><link rel="prefetch" href="/Weblog/assets/js/86.632f014f.js"><link rel="prefetch" href="/Weblog/assets/js/87.7737cd73.js"><link rel="prefetch" href="/Weblog/assets/js/88.1ec9c00d.js"><link rel="prefetch" href="/Weblog/assets/js/89.bbeb975f.js"><link rel="prefetch" href="/Weblog/assets/js/9.c685ce8f.js"><link rel="prefetch" href="/Weblog/assets/js/90.eda536dd.js"><link rel="prefetch" href="/Weblog/assets/js/91.391681fc.js"><link rel="prefetch" href="/Weblog/assets/js/92.dca04870.js"><link rel="prefetch" href="/Weblog/assets/js/93.01d44a2a.js"><link rel="prefetch" href="/Weblog/assets/js/94.f941a99a.js"><link rel="prefetch" href="/Weblog/assets/js/95.232bf755.js"><link rel="prefetch" href="/Weblog/assets/js/96.d381c6e0.js"><link rel="prefetch" href="/Weblog/assets/js/97.2a0ba8ba.js"><link rel="prefetch" href="/Weblog/assets/js/98.001e708c.js"><link rel="prefetch" href="/Weblog/assets/js/99.0ff7167d.js">
    <link rel="stylesheet" href="/Weblog/assets/css/styles.bc17a3fe.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/Weblog/" class="home-link router-link-active"><!----><span class="site-name">
      AlexTao 的 博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link router-link-active">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link router-link-active">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>Javascript</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/Weblog/javascript/" aria-current="page" class="sidebar-link">高效javascript</a></li><li><a href="/Weblog/javascript/33个概念.html" class="sidebar-link">JavaScript开发者应懂的33个概念</a></li><li><a href="/Weblog/javascript/js备忘录.html" class="sidebar-link">JS备忘录</a></li><li><a href="/Weblog/javascript/js概念.html" class="active sidebar-link">JS 概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#bfc规范" class="sidebar-link">BFC规范</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#js-自定义事件实现" class="sidebar-link">js 自定义事件实现</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#事件委托，目的，功能，写法" class="sidebar-link">事件委托，目的，功能，写法</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#同源策略" class="sidebar-link">同源策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#ajax-原理" class="sidebar-link">Ajax 原理</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#cookie" class="sidebar-link">Cookie</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#浏览器本地存储" class="sidebar-link">浏览器本地存储</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#session" class="sidebar-link">session</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#token" class="sidebar-link">Token</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#线程，进程" class="sidebar-link">线程，进程</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#负载均衡" class="sidebar-link">负载均衡</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#cdn缓存" class="sidebar-link">CDN缓存</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#url到页面加载显示完成" class="sidebar-link">URL到页面加载显示完成</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#seo优化技巧" class="sidebar-link">SEO优化技巧</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#垃圾回收机制方式及内存管理" class="sidebar-link">垃圾回收机制方式及内存管理</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#前端模块化" class="sidebar-link">前端模块化</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#模块化规范" class="sidebar-link">模块化规范</a></li></ul></li><li><a href="/Weblog/javascript/片段和trick.html" class="sidebar-link">片段和trick</a></li><li><a href="/Weblog/javascript/常用正则.html" class="sidebar-link">常用正则表达式</a></li><li><a href="/Weblog/javascript/处理异步的方法.html" class="sidebar-link">处理异步的方法</a></li><li><a href="/Weblog/javascript/字符串.html" class="sidebar-link">字符串</a></li><li><a href="/Weblog/javascript/数组.html" class="sidebar-link">数组</a></li><li><a href="/Weblog/javascript/typeof instanceof.html" class="sidebar-link">typeof  &amp;&amp; instanceof</a></li><li><a href="/Weblog/javascript/浅谈 JSON.html" class="sidebar-link">浅谈 JSON</a></li><li><a href="/Weblog/javascript/详解闭包.html" class="sidebar-link">详解闭包</a></li><li><a href="/Weblog/javascript/执行上下文.html" class="sidebar-link">执行上下文</a></li><li><a href="/Weblog/javascript/this.html" class="sidebar-link">this</a></li><li><a href="/Weblog/javascript/深浅拷贝.html" class="sidebar-link">深浅拷贝</a></li><li><a href="/Weblog/javascript/面向对象.html" class="sidebar-link">面向对象</a></li><li><a href="/Weblog/javascript/继承方式.html" class="sidebar-link">继承方式</a></li><li><a href="/Weblog/javascript/节流防抖.html" class="sidebar-link">节流防抖</a></li><li><a href="/Weblog/javascript/Promise.html" class="sidebar-link">Promise</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="js-概念">JS 概念</h1><h2 id="bfc规范">BFC规范</h2><p>级格式化上下文，是CSS中的一个渲染机制，BFC就相当于一个盒子，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它.</p><ul><li><strong>创建BFC</strong></li></ul><p>1.float的值不是none</p><p>2.position 的值不是static或者relative</p><p>3.display的值是inline-block,table-cell,flex,table-caption或者inline-flex</p><p>4.overflow的值不是visible</p><ul><li><strong>BFC特性</strong></li></ul><p>1.内部的BOX会在垂直方向上一个接一个的放置</p><p>2.于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。</p><p>3.每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</p><p>4.BFC的区域不会与float的元素区域重叠</p><p>5.计算BFC的高度时，浮动子元素也参与计算</p><p>6.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</p><ul><li><strong>BFC布局中应用</strong></li></ul><p>要阻止margin重叠，只要将俩个元素别放在一个BFC中即可 使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题 与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式. 特点在于左右俩栏的宽度固定，中间栏可以根据浏览器宽度自适应</p><h2 id="js-自定义事件实现">js 自定义事件实现</h2><ol><li>原生提供了3个方法实现自定义事件</li><li>createEvent，设置事件类型，是 html 事件还是 鼠标事件</li><li>initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件</li><li>dispatchEvent 触发事件</li></ol><h2 id="事件委托，目的，功能，写法">事件委托，目的，功能，写法</h2><ul><li><p>把一个或者一组元素的事件委托到它的父层或者更外层元素上</p></li><li><p>优点，减少内存消耗，动态绑定事件</p></li><li><p>target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this)</p></li><li><div class="language-text extra-class"><pre class="language-text"><code>window.onload = function(){
　　var oUl = document.getElementById(&quot;ul1&quot;);
　　oUl.onclick = function(ev){
　　　　var ev = ev || window.event;
　　　　var target = ev.target || ev.srcElement;
　　　　if(target.nodeName.toLowerCase() == 'li'){
　 　　　　　　 alert(123);
　　　　　　　  alert(target.innerHTML);
　　　　}
　　}
}
</code></pre></div></li></ul><h2 id="同源策略">同源策略</h2><p>源（origin）就是协议、域名和端口号。</p><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。</p><p>这个策略可以阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限。</p><h3 id="跨域">跨域</h3><p>浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。</p><p><strong>cors-跨域资源共享（Cross-origin resource sharing）</strong> ---&gt;这种方式使用了一个新的<code>Origin</code>请求头和一个新的<code>Access-Control-Allow-Origin</code>响应头扩展了HTTP。</p><p>允许服务端设置<code>Access-Control-Allow-Origin</code>头标识哪些站点可以请求文件，或者设置<code>Access-Control-Allow-Origin</code>头为&quot;*&quot;， （IE8---IE9---jquery.xdomainrequest.min.js）</p><p><strong>JSONP</strong>---&gt;JOSNP允许页面接受另一个域的JSON数据，通过在页面增加一个可以从其它域加载带有回调的JSON响应的<code>&lt;script&gt;</code>标签。</p><ol><li><p>使用这种方法，只要是个网站都可以拿到b.com里的数据，存在安全性问题。需要网站双方商议基础token的身份验证，这里不详述。</p><p>. 只能是GET，不能POST。 . 可能被注入恶意代码，篡改页面内容，可以采用字符串过滤来规避此问题。</p></li></ol><p><strong>postMessage() -跨文档通信</strong>---&gt;这种方式允许一个页面的脚本发送文本信息到另一个页面的脚本中，不管脚本是否跨域。</p><p>在一个window对象上调用<code>postMessage()</code>会异步的触发window上的<code>onmessage</code>事件，然后触发定义好的事件处理方法。</p><p>一个页面上的脚本仍然不能直接访问另外一个页面上的方法或者变量，但是他们可以安全的通过消息传递技术交流。</p><p><strong>window.name</strong>---&gt;window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><h2 id="ajax-原理">Ajax 原理</h2><p>Ajax的全称是Asynchronous JavaScript and XML，即异步JavaScript+XML。  是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>由以下几种技术组成：</p><ul><li>HTML/XHTML——主要的内容表示语言。</li><li>CSS——为XHTML提供文本格式定义。</li><li>DOM——对已载入的页面进行动态更新。</li><li>XML——数据交换格式。</li><li>XSLT——将XML转换为XHTML（用CSS修饰样式）。</li><li>XMLHttp——用XMLHttpRequest来和服务器进行异步通信，是主要的通信代理。</li><li>JavaScript——用来编写Ajax引擎的脚本语言。</li></ul><p><strong>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</strong></p><p><strong>XMLHttpRequest对象</strong></p><p>当需要异步与服务器交换数据时，需要XMLHttpRequest对象来异步交换。 XMLHttpRequest对象的主要<strong>属性</strong>有：</p><ul><li>onreadystatechange——每次状态改变所触发事件的事件处理程序。</li><li>responseText——从服务器进程返回数据的字符串形式。</li><li>responseXML——从服务器进程返回的DOM兼容的文档数据对象。</li><li>status——从服务器返回的数字代码，如404（未找到）和200（已就绪）。</li><li>status Text——伴随状态码的字符串信息。</li><li>readyState——对象状态值。对象状态值有以下几个：
<ul><li>0 - (未初始化)还没有调用send()方法</li><li>1 - (载入)已调用send()方法，正在发送请求</li><li>2 - (载入完成)send()方法执行完成</li><li>3 - (交互)正在解析响应内容</li><li>4 - (完成)响应内容解析完成，可以在客户端调用了</li></ul></li></ul><p>XMLHttpRequest对象有两个重要<strong>方法</strong> open与send。</p><p><strong>创建过程</strong></p><ul><li><p>创建XMLHttpRequest对象</p><ul><li><div class="language-text extra-class"><pre class="language-text"><code>  var xmlhttp = new XMLHttpRequest();                    //IE7及以上
  var xmlhttp = new ActiveXObject('Microsoft.XMLHTTP'); //IE5 和 IE6
</code></pre></div></li></ul></li><li><p>打开链接</p><ul><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.open( method, url, async );  
</code></pre></div></li><li><div class="language-text extra-class"><pre class="language-text"><code>method：请求的类型，GET 或 POST
url：文件在服务器上的位置
async：true（异步）或 false（同步）
同步：指发出数据后，等接收到响应以后再发送下一个数据包的通讯方式。
异步：指发出数据后，不用等待接收到响应，接着发送下一个数据包的通讯方式。
</code></pre></div></li></ul></li><li><p>发送请求</p><ul><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.send(string);
</code></pre></div><ul><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.send();    //GET方式
</code></pre></div></li><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);    //向请求添加HTTP头
xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);   //POST方式
</code></pre></div></li></ul></li><li><p><strong>GET 还是 POST？</strong></p><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求：  a. 无法使用缓存文件（更新服务器上的文件或数据库）；  b. 向服务器发送大量数据（POST 没有数据量限制）；  c. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。</p></li></ul></li><li><p>接收服务器相应</p><ul><li><p><strong>Onreadystatechange</strong> ---存储函数（或函数名），每当readyState 属性改变时，就会调用该函数。</p></li><li><p>readyState</p><p>---存有XMLHttpRequest 的状态信息，从 0 到 4 发生变化。</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul></li><li><p>Status（HTTP状态码）</p><ul><li>1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。</li><li>2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。( 200:'OK' )</li><li>3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。( 304:'Not Modified' )</li><li>4字头：请求错误。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</li><li>5、6字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。</li></ul></li></ul></li></ul><p>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p><div class="language-text extra-class"><pre class="language-text"><code>//GET 方式：
  function ajax(url,success,error){
      if(window.XMLHttpRequest){
          var oAjax = new XMLHttpRequest();
      }else{
          var oAjax = new ActiveXObject('Microsoft.XMLHTTP');
      }
      oAjax.open('GET',url,true);
      oAjax.send();
      oAjax.onreadystatechange = function(){
          if(oAjax.readyState==4){
              if(oAjax.status&gt;=200&amp;&amp;oAjax.status&lt;300||oAjax.status==304){
                  success&amp;&amp;success(oAjax.responseText);    //成功的回调函数
              }else{
                  error&amp;&amp;error(oAjax.status);              //失败的回调函
              }
          }
      };
  }
//POST 方式：
  function ajax(url,success,error){
      if(window.XMLHttpRequest){
          var oAjax = new XMLHttpRequest();
      }else{
          var oAjax = new ActiveXObject('Microsoft.XMLHTTP');
      }
      oAjax.open('POST ',url,true);
      oAjax.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
      oAjax.send('fname=Bill&amp;lname=Gates');
      oAjax.onreadystatechange = function(){
          if(oAjax.readyState==4){
              if(oAjax.status&gt;=200&amp;&amp;oAjax.status&lt;300||oAjax.status==304){
                  success&amp;&amp;success(oAjax.responseText);    //成功的回调函数
              }else{
                  error&amp;&amp;error(oAjax.status);              //失败的回调函
              }
          }
      };
  }
$.ajax({
    type: &quot;get&quot;,
    url: &quot;http://www.github.com/alex&quot;,
    data: {
    	id : &quot;1&quot;,
    	name : &quot;alex&quot;,
    },
    dataType: &quot;json&quot;,
    beforeSend: function(XMLHttpRequest) {
        //ShowLoading();
    },
    success: function(data, textStatus) {
        //请求成功处理
    },
    complete: function(XMLHttpRequest, textStatus) {
        //HideLoading();
    },
    error: function() {
        //请求出错处理
    }
});
</code></pre></div><h3 id="get和post">get和post</h3><ul><li>GET从指定的资源请求数据，POST 向指定的资源提交要被处理的数据</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>GET参数通过URL传递，POST放在Request body中。</li><li>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li></ul><h3 id="cookie自动登录">cookie自动登录</h3><div class="language-text extra-class"><pre class="language-text"><code>//记住用户名密码----是否自动登录
function Save() {
    if ($(&quot;#rememberMe&quot;).prop(&quot;checked&quot;)) {
        var str_username = $(&quot;#NameText&quot;).val();//用户名
        var str_password = $(&quot;#inputPassword&quot;).val();//密码
        $.cookie(&quot;rmbUser&quot;, &quot;true&quot;, { expires: 7 }); //存储一个带7天期限的cookie
        $.cookie(&quot;username&quot;, str_username, { expires: 7 });
        $.cookie(&quot;password&quot;, str_password, { expires: 7 });
    }else {
        $.cookie(&quot;rmbUser&quot;, &quot;false&quot;, { expire: -1 });
        $.cookie(&quot;username&quot;, &quot;&quot;, { expires: -1 });
        $.cookie(&quot;password&quot;, &quot;&quot;, { expires: -1 });
    }

    if ($(&quot;#autoLogin&quot;).prop(&quot;checked&quot;)) {
        var str_username = $(&quot;#NameText&quot;).val();
        var str_password = $(&quot;#inputPassword&quot;).val();
        $.cookie(&quot;auto&quot;, &quot;true&quot;, { expires: 7 }); //存储一个带7天期限的cookie
        $.cookie(&quot;username&quot;, str_username, { expires: 7 });
        $.cookie(&quot;password&quot;, str_password, { expires: 7 });
    }else {
        $.cookie(&quot;auto&quot;, &quot;false&quot;, { expire: -1 });
        $.cookie(&quot;username&quot;, &quot;&quot;, { expires: -1 });
        $.cookie(&quot;password&quot;, &quot;&quot;, { expires: -1 });
    }
}
$(&quot;#autoLogin&quot;).change(function() {
    if($(&quot;#autoLogin&quot;).prop(&quot;checked&quot;)){
    	$.cookie(&quot;auto&quot;, &quot;true&quot;, { expires: 7 });
    }else{
    	$.cookie(&quot;auto&quot;, &quot;false&quot;, { expires: 7 });
    }
});

if ($.cookie(&quot;rmbUser&quot;) == &quot;true&quot;) {
    $(&quot;#rememberMe&quot;).attr(&quot;checked&quot;, true);
    $(&quot;#NameText&quot;).val($.cookie(&quot;username&quot;));
    $(&quot;#inputPassword&quot;).val($.cookie(&quot;password&quot;));
}

if ($.cookie(&quot;auto&quot;) == &quot;true&quot;) {
    setTimeout(function(){
    	if($.cookie(&quot;auto&quot;) == &quot;true&quot;) 
    	window.location.href='下一个界面';
    },5000);
}
</code></pre></div><h2 id="cookie">Cookie</h2><ul><li>特点
<ul><li>每个特定的域名下最多生成20个cookie
<ul><li>1.IE6及跟早版本最多20个cookie</li><li>2.IE7和之后版本最多50个cookie</li><li>3.firefox最多50个cookie</li><li>4.chrome和safire没有硬性限制</li></ul></li><li>cookie大小大约4096字节，一般不超过4095个字节。</li></ul></li><li>优点
<ul><li>极高的扩张性和可用性
<ul><li>1.通过良好的编程，控制保存在cookie中的session对象的大小。</li><li>2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</li><li>3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li><li>4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</li></ul></li></ul></li><li>缺点
<ul><li>1
<ul><li>1.cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</li><li>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</li><li>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li></ul></li></ul></li></ul><h2 id="浏览器本地存储">浏览器本地存储</h2><ul><li><p><strong>localStotrage</strong></p><p>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</p><ul><li>优点
<ul><li>1.localStorage拓展了cookie的4K限制；</li><li>2.localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的；</li><li>3.localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。</li></ul></li><li>缺点
<ul><li>1.浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性；</li><li>2.目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换；</li><li>3.localStorage在浏览器的隐私模式下面是不可读取的；</li><li>4.localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡；</li><li>5.localStorage不能被爬虫抓取到。</li></ul></li></ul></li><li><p><strong>sessionStrage</strong></p><p>本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</p></li></ul><h3 id="web-storage-与-cookie">web storage 与 cookie</h3><p><strong>相同点</strong> ： 1.存储在客户端 2.同源策略影响</p><p><strong>不同点</strong> ：</p><p>1.cookie的大小是受限的，cookie大小4KB，storage大小5M。</p><p>2.每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，storage不会发送信息去服务器。</p><p>3.cookie还需要指定作用域，不可以跨域调用 cookie需要前端开发者自己封装setCookie，getCookie。</p><p>4.cookie在过期时间内有效；sessionStorage在当前浏览器窗口关闭自动删除，会话级别；loaclStoage永久有效，除非主动删除。</p><h2 id="session">session</h2><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p><p>当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</p><p>用户首次与Web服务器建立连接的时候，服务器会给用户分发一个 SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在 HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端。这个SessionID就是保存在客户端的，属于客户端Session。其实客户端Session默认是以cookie的形式来存储的。</p><p>当然我们客户端可以禁用cookie,这时候服务器端就拿不到sessionID。</p><h2 id="token">Token</h2><p>Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><h2 id="线程，进程">线程，进程</h2><ul><li>进程
<ul><li>所存储资源是操作系统由虚拟内存机制来管理和分配的。<strong>进程应该是操作系统分配存储资源的最小单元。</strong></li><li>一个进程可以有多个线程，但至少有一个线程</li><li>进程表示一个逻辑控制流，就是一种计算过程，它造成一个假象，好像这个进程一直在独占CPU资源</li><li>进程拥有一个独立的虚拟内存地址空间，它造成一个假象，好像这个进程一致在独占存储器资源</li></ul></li><li>线程
<ul><li>线程是最小的执行单元</li><li>一个线程只能属于一个进程</li></ul></li></ul><h2 id="负载均衡">负载均衡</h2><ol><li>当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力以及网站的整体性能 。</li><li>服务器集群负载均衡原理？</li></ol><h2 id="cdn缓存">CDN缓存</h2><ol><li>CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源</li><li>(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件</li><li>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265" target="_blank" rel="noopener noreferrer">内容分发网络<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E5%99%A8/4576219" target="_blank" rel="noopener noreferrer">节点服务器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>所构成的在现有的互联网基础之上的一层智能<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/855117" target="_blank" rel="noopener noreferrer">虚拟网络<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，CDN系统能够实时地根据<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/7489548" target="_blank" rel="noopener noreferrer">网络流量<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li></ol><h2 id="url到页面加载显示完成">URL到页面加载显示完成</h2><ul><li>首先，在浏览器地址栏中输入url</li><li>浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
<ul><li>具体过程：</li><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求</li><li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)</li><li>ISP缓存：若上述均失败，继续向ISP搜索</li></ul></li><li>发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。</li><li>浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。</li><li>握手成功后，浏览器向服务器发送http请求，请求数据包。</li><li>服务器处理收到的请求，将数据返回至浏览器</li><li>浏览器收到HTTP响应</li><li>读取页面内容，浏览器渲染，解析html源码</li><li>生成Dom树、解析css样式、js交互</li><li>户端和服务器交互</li><li>ajax查询</li></ul><h2 id="seo优化技巧">SEO优化技巧</h2><p>前端开发工程师不仅需要要跟视觉设计师、交互式设计师配合，完美还原设计图稿，编写兼容各大浏览器、加载速度快、用户体验好的页面。现在还需要跟SEO人员配合，调整页面的代码结构和标签。</p><ul><li>简化代码结构，更利于搜索引擎分析抓取有用内容：页面尽量采用DIV+CSS，当然，表格展现模式用table还是比div方便很多的;所有js、css采用外联方式，图片采用css精灵，减少请求次数。看下下面同样的内容，用div和talbe布局的代码比较，显而易见用div简便的多。</li><li>重要内容优先加载(第一个链接最好是网站主关键词，不刻意要求)，可以用css来处理，索引一篇文章的长度也是有限制的，一定要把最重要的内容，优先展现给蜘蛛，这方面你可以通过查看一些比较大的网页快照来求证。</li><li>每个页面只能出现一次H1标签，H2标签可以多次：H1权重很高，普遍认为仅次于title，一般资讯详情页的标题、商品详情页的标题，都放在H1里。</li><li>图片一定要添加alt属性，title属性可选：蜘蛛不认识图片上的内容，只能通过alt属性来判断，如果是商品列表页，所有商品都加了alt和title的话，容易造成堆砌关键词，所以我一般是只加alt属性。</li><li>图片大小声明：如果图片大小不做定义的话，页面需要重新渲染，就会影响到加载速度。</li><li>链接可根据需求添加title属性以及nofllow值;非特殊性链接，链接地址一定要写入herf属性，有些前端开发人员为了省事，直接用div加个click事件当链接，在视觉上和使用上确实是实现了链接效果，但是做过SEO优化的人 员都知道，蜘蛛目前对于js的支持很差，基本无法读取里面的链接地址。所以说用click事件是绝对不允许的，特别是一些重要的导航链接。</li><li>页面内容尽量不要做成flash、图片、视频，这些东西蜘蛛是抓不到的，就算是必须的，也要生成相应的静态页面。有很多企业站看着很炫，全站flash，老板看着是爽了，做SEO优化的人员就要抓狂了，全站没一个链接。</li><li>除首页外别的页面最好要加上面包屑型导航，导航结构一定要清晰。</li><li>做好404页面，一般会加首页链接及错误提示，并测试其返回状态码为404：
<ul><li>1、用户体验友好，可以留住用户，不至于直接关闭页面;</li><li>2、蜘蛛友好，可以返回抓取其他页面。</li></ul></li><li>网站结构呈扁平状树型，目录结构不宜过深，每个页面离首页最多点击不超过3次，过深不利于搜索引擎的抓取。</li></ul><h2 id="垃圾回收机制方式及内存管理">垃圾回收机制方式及内存管理</h2><ul><li>回收机制方式
<ul><li><strong>定义和用法</strong>：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</li><li><strong>原理</strong>：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</li></ul></li><li>垃圾回收策略：标记清除(较为常用)和引用计数
<ul><li>标记清除
<ul><li>定义和用法
<ul><li>当变量进入环境时，将变量标记&quot;进入环境&quot;，当变量离开环境时，标记为：&quot;离开环境&quot;。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</li><li>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</li></ul></li></ul></li><li>引用计数
<ul><li>定义和用法
<ul><li>引用计数是跟踪记录每个值被引用的次数。</li></ul></li><li>基本原理
<ul><li>就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</li></ul></li></ul></li></ul></li><li>内存管理
<ul><li>什么时候触发垃圾回收？
<ul><li>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。</li><li>IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。</li><li>E7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。</li><li>合理的GC方案：
<ul><li>遍历所有可访问的对象;</li><li>回收已不可访问的对象</li></ul></li><li>GC缺陷：
<ul><li>停止响应其他操作</li></ul></li><li>4、GC优化策略：
<ul><li>分代回收（Generation GC）</li><li>增量GC</li></ul></li></ul></li></ul></li><li>开发过程中遇到的内存泄露情况，如何解决的？
<ul><li>定义和用法
<ul><li>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。</li></ul></li><li>内存泄露的几种情况:
<ul><li>当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。</li><li>由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。</li></ul></li></ul></li></ul><h2 id="前端模块化">前端模块化</h2><h3 id="_1-什么是模块">1.什么是模块?</h3><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="_2-模块化的进化过程">2.模块化的进化过程</h3><ul><li><strong>全局function模式 : 将不同的功能封装成不同的全局函数</strong><ul><li>编码: 将不同的功能封装成不同的全局函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li></ul></li></ul><div class="language- extra-class"><pre class="language-text"><code>function m1(){
  //...
}
function m2(){
  //...
}
</code></pre></div><ul><li><strong>namespace模式 : 简单对象封装</strong><ul><li>作用: 减少了全局变量，解决命名冲突</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li></ul><div class="language- extra-class"><pre class="language-text"><code>let myModule = {
  data: 'www.baidu.com',
  foo() {
    console.log(`foo() ${this.data}`)
  },
  bar() {
    console.log(`bar() ${this.data}`)
  }
}
myModule.data = 'other data' //能直接修改模块内部的数据
myModule.foo() // foo() other data
</code></pre></div><p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><ul><li><strong>IIFE模式：匿名函数自调用(闭包)</strong><ul><li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>问题: 如果当前这个模块依赖另一个模块怎么办?</li></ul></li></ul><div class="language- extra-class"><pre class="language-text"><code>// index.html文件
&lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    myModule.foo()
    myModule.bar()
    console.log(myModule.data) //undefined 不能访问模块内部数据
    myModule.data = 'xxxx' //不是修改的模块内部的data
    myModule.foo() //没有改变
&lt;/script&gt;
// module.js文件
(function(window) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar } //ES6写法
})(window)
</code></pre></div><ul><li><strong>IIFE模式增强 : 引入依赖</strong></li></ul><p>这就是现代模块实现的基石</p><div class="language- extra-class"><pre class="language-text"><code>// module.js文件
(function(window, $) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
    $('body').css('background', 'red')
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar }
})(window, jQuery)
 // index.html文件
  &lt;!-- 引入的js必须有一定顺序 --&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    myModule.foo()
  &lt;/script&gt;
</code></pre></div><p>上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><h3 id="_3-模块化的好处">3. 模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="_4-引入多个-script-后出现出现问题">4. 引入多个<code>&lt;script&gt;</code>后出现出现问题</h3><ul><li>请求过多</li></ul><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p><ul><li>依赖模糊</li></ul><p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p><ul><li>难以维护</li></ul><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。
模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。</p><h2 id="模块化规范">模块化规范</h2><h3 id="_1-commonjs">1.CommonJS</h3><h4 id="_1-概述">(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="_2-特点">(2)特点</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h4 id="_3-基本语法">(3)基本语法</h4><ul><li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p>此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性</strong>。</p><div class="language- extra-class"><pre class="language-text"><code>// example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
</code></pre></div><p>上面代码通过module.exports输出变量x和函数addX。</p><div class="language- extra-class"><pre class="language-text"><code>var example = require('./example.js');//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
console.log(example.x); // 5
console.log(example.addX(1)); // 6
</code></pre></div><p>require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错</strong>。</p><h4 id="_4-模块的加载机制">(4)模块的加载机制</h4><p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：</p><div class="language- extra-class"><pre class="language-text"><code>// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
</code></pre></div><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><div class="language- extra-class"><pre class="language-text"><code>// main.js
var counter = require('./lib').counter;
var incCounter = require('./lib').incCounter;

console.log(counter);  // 3
incCounter();
console.log(counter); // 3
</code></pre></div><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p><h4 id="_5-服务器端实现">(5)服务器端实现</h4><h4 id="①下载安装node-js">①下载安装node.js</h4><h4 id="②创建项目结构">②创建项目结构</h4><p><strong>注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写</strong></p><div class="language- extra-class"><pre class="language-text"><code>|-modules
  |-module1.js
  |-module2.js
  |-module3.js
|-app.js
|-package.json
  {
    &quot;name&quot;: &quot;commonJS-node&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
  }
</code></pre></div><h4 id="③下载第三方模块">③下载第三方模块</h4><div class="language- extra-class"><pre class="language-text"><code>npm install uniq --save // 用于数组去重
</code></pre></div><h4 id="④定义模块代码">④定义模块代码</h4><div class="language- extra-class"><pre class="language-text"><code>//module1.js
module.exports = {
  msg: 'module1',
  foo() {
    console.log(this.msg)
  }
}
//module2.js
module.exports = function() {
  console.log('module2')
}
//module3.js
exports.foo = function() {
  console.log('foo() module3')
}
exports.arr = [1, 2, 3, 3, 2]
// app.js文件
// 引入第三方库，应该放置在最前面
let uniq = require('uniq')
let module1 = require('./modules/module1')
let module2 = require('./modules/module2')
let module3 = require('./modules/module3')

module1.foo() //module1
module2() //module2
module3.foo() //foo() module3
console.log(uniq(module3.arr)) //[ 1, 2, 3 ]
</code></pre></div><h4 id="⑤通过node运行app-js">⑤通过node运行app.js</h4><p>命令行输入<code>node app.js</code>，运行JS文件</p><h4 id="_6-浏览器端实现-借助browserify">(6)浏览器端实现(借助Browserify)</h4><h4 id="①创建项目结构">①创建项目结构</h4><div class="language- extra-class"><pre class="language-text"><code>|-js
  |-dist //打包生成文件的目录
  |-src //源码所在的目录
    |-module1.js
    |-module2.js
    |-module3.js
    |-app.js //应用主源文件
|-index.html //运行于浏览器上
|-package.json
  {
    &quot;name&quot;: &quot;browserify-test&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
  }
</code></pre></div><h4 id="②下载browserify">②下载browserify</h4><ul><li>全局: npm install browserify -g</li><li>局部: npm install browserify --save-dev</li></ul><h4 id="③定义模块代码-同服务器端">③定义模块代码(同服务器端)</h4><p>注意：<code>index.html</code>文件要运行在浏览器上，需要借助browserify将<code>app.js</code>文件打包编译，如果直接在<code>index.html</code>引入<code>app.js</code>就会报错！</p><h4 id="④打包处理js">④打包处理js</h4><p>根目录下运行<code>browserify js/src/app.js -o js/dist/bundle.js</code></p><h4 id="⑤页面使用引入">⑤页面使用引入</h4><p>在index.html文件中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="_2-amd">2.AMD</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</strong>。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p><h4 id="_1-amd规范基本语法">(1)AMD规范基本语法</h4><p><strong>定义暴露模块</strong>:</p><div class="language- extra-class"><pre class="language-text"><code>//定义没有依赖的模块
define(function(){
   return 模块
})
//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})
</code></pre></div><p><strong>引入使用模块</strong>:</p><div class="language- extra-class"><pre class="language-text"><code>require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})
</code></pre></div><h4 id="_2-未使用amd规范与使用require-js">(2)未使用AMD规范与使用require.js</h4><p>通过比较两者的实现方法，来说明使用AMD规范的好处。</p><ul><li>未使用AMD规范</li></ul><div class="language- extra-class"><pre class="language-text"><code>// dataService.js文件
(function (window) {
  let msg = 'www.baidu.com'
  function getMsg() {
    return msg.toUpperCase()
  }
  window.dataService = {getMsg}
})(window)
 // alerter.js文件
(function (window, dataService) {
  let name = 'Tom'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  window.alerter = {showMsg}
})(window, dataService)
// main.js文件
(function (alerter) {
  alerter.showMsg()
})(alerter)
// index.html文件
&lt;div&gt;&lt;h1&gt;Modular Demo 1: 未使用AMD(require.js)&lt;/h1&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/modules/dataService.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/modules/alerter.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！</strong></p><ul><li>使用require.js</li></ul><p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<strong>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</strong>。
接下来介绍AMD规范在浏览器实现的步骤：</p><h4 id="①下载require-js-并引入">①下载require.js, 并引入</h4><ul><li>官网: <code>http://www.requirejs.cn/</code></li><li>github : <code>https://github.com/requirejs/requirejs</code></li></ul><p>然后将require.js导入项目: js/libs/require.js</p><h4 id="②创建项目结构-2">②创建项目结构</h4><div class="language- extra-class"><pre class="language-text"><code>|-js
  |-libs
    |-require.js
  |-modules
    |-alerter.js
    |-dataService.js
  |-main.js
|-index.html
</code></pre></div><h4 id="③定义require-js的模块代码">③定义require.js的模块代码</h4><div class="language- extra-class"><pre class="language-text"><code>// dataService.js文件 
// 定义没有依赖的模块
define(function() {
  let msg = 'www.baidu.com'
  function getMsg() {
    return msg.toUpperCase()
  }
  return { getMsg } // 暴露模块
})
//alerter.js文件
// 定义有依赖的模块
define(['dataService'], function(dataService) {
  let name = 'Tom'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  // 暴露模块
  return { showMsg }
})
// main.js文件
(function() {
  require.config({
    baseUrl: 'js/', //基本路径 出发点在根目录下
    paths: {
      //映射: 模块标识名: 路径
      alerter: './modules/alerter', //此处不能写成alerter.js,会报错
      dataService: './modules/dataService'
    }
  })
  require(['alerter'], function(alerter) {
    alerter.showMsg()
  })
})()
// index.html文件
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Modular Demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 引入require.js并指定js主文件的入口 --&gt;
    &lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><h4 id="④页面引入require-js模块">④页面引入require.js模块:</h4><p>在index.html引入 <code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></p><p>**此外在项目中如何引入第三方库？**只需在上面代码的基础稍作修改：</p><div class="language- extra-class"><pre class="language-text"><code>// alerter.js文件
define(['dataService', 'jquery'], function(dataService, $) {
  let name = 'Tom'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  $('body').css('background', 'green')
  // 暴露模块
  return { showMsg }
})
// main.js文件
(function() {
  require.config({
    baseUrl: 'js/', //基本路径 出发点在根目录下
    paths: {
      //自定义模块
      alerter: './modules/alerter', //此处不能写成alerter.js,会报错
      dataService: './modules/dataService',
      // 第三方库模块
      jquery: './libs/jquery-1.10.1' //注意：写成jQuery会报错
    }
  })
  require(['alerter'], function(alerter) {
    alerter.showMsg()
  })
})()
</code></pre></div><p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。
<strong>小结</strong>：通过两者的比较，可以得出<strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p><h3 id="_3-cmd">3.CMD</h3><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="_1-cmd规范基本语法">(1)CMD规范基本语法</h4><p><strong>定义暴露模块：</strong></p><div class="language- extra-class"><pre class="language-text"><code>//定义没有依赖的模块
define(function(require, exports, module){
  exports.xxx = value
  module.exports = value
})
//定义有依赖的模块
define(function(require, exports, module){
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
  //暴露模块
  exports.xxx = value
})
</code></pre></div><p><strong>引入使用模块：</strong></p><div class="language- extra-class"><pre class="language-text"><code>define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
</code></pre></div><h4 id="_2-sea-js简单使用教程">(2)sea.js简单使用教程</h4><h4 id="①下载sea-js-并引入">①下载sea.js, 并引入</h4><ul><li>官网: http://seajs.org/</li><li>github : https://github.com/seajs/seajs</li></ul><p>然后将sea.js导入项目: js/libs/sea.js</p><h4 id="②创建项目结构-3">②创建项目结构</h4><div class="language- extra-class"><pre class="language-text"><code>|-js
  |-libs
    |-sea.js
  |-modules
    |-module1.js
    |-module2.js
    |-module3.js
    |-module4.js
    |-main.js
|-index.html
</code></pre></div><h4 id="③定义sea-js的模块代码">③定义sea.js的模块代码</h4><div class="language- extra-class"><pre class="language-text"><code>// module1.js文件
define(function (require, exports, module) {
  //内部变量数据
  var data = 'atguigu.com'
  //内部函数
  function show() {
    console.log('module1 show() ' + data)
  }
  //向外暴露
  exports.show = show
})
// module2.js文件
define(function (require, exports, module) {
  module.exports = {
    msg: 'I Will Back'
  }
})
// module3.js文件
define(function(require, exports, module) {
  const API_KEY = 'abc123'
  exports.API_KEY = API_KEY
})
// module4.js文件
define(function (require, exports, module) {
  //引入依赖模块(同步)
  var module2 = require('./module2')
  function show() {
    console.log('module4 show() ' + module2.msg)
  }
  exports.show = show
  //引入依赖模块(异步)
  require.async('./module3', function (m3) {
    console.log('异步引入依赖模块3  ' + m3.API_KEY)
  })
})
// main.js文件
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
</code></pre></div><h4 id="④在index-html中引入">④在index.html中引入</h4><div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  seajs.use('./js/modules/main')
&lt;/script&gt;
</code></pre></div><h3 id="_4-es6模块化">4.ES6模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h4 id="_1-es6模块化语法">(1)ES6模块化语法</h4><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><div class="language- extra-class"><pre class="language-text"><code>/** 定义模块 math.js **/
var basicNum = 0;
var add = function (a, b) {
    return a + b;
};
export { basicNum, add };
/** 引用模块 **/
import { basicNum, add } from './math';
function test(ele) {
    ele.textContent = add(99 + basicNum);
}
</code></pre></div><p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p><div class="language- extra-class"><pre class="language-text"><code>// export-default.js
export default function () {
  console.log('foo');
}
// import-default.js
import customName from './export-default';
customName(); // 'foo'
</code></pre></div><p>模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><h4 id="_2-es6-模块与-commonjs-模块的差异">(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：</p><p><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p><p><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p><p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p><div class="language- extra-class"><pre class="language-text"><code>// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}
// main.js
import { counter, incCounter } from './lib';
console.log(counter); // 3
incCounter();
console.log(counter); // 4
</code></pre></div><p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p><h4 id="_3-es6-babel-browserify使用教程">(3) ES6-Babel-Browserify使用教程</h4><p>简单来说就一句话：<strong>使用Babel将ES6编译为ES5代码，使用Browserify编译打包js</strong>。</p><h4 id="①定义package-json文件">①定义package.json文件</h4><div class="language- extra-class"><pre class="language-text"><code> {
   &quot;name&quot; : &quot;es6-babel-browserify&quot;,
   &quot;version&quot; : &quot;1.0.0&quot;
 }
</code></pre></div><h4 id="②安装babel-cli-babel-preset-es2015和browserify">②安装babel-cli, babel-preset-es2015和browserify</h4><ul><li><p>npm install babel-cli browserify -g</p></li><li><p>npm install babel-preset-es2015 --save-dev</p></li><li><p>preset 预设(将es6转换成es5的所有插件打包)</p></li></ul><h4 id="③定义-babelrc文件">③定义.babelrc文件</h4><div class="language- extra-class"><pre class="language-text"><code>  {
    &quot;presets&quot;: [&quot;es2015&quot;]
  }
</code></pre></div><h4 id="④定义模块代码-2">④定义模块代码</h4><div class="language- extra-class"><pre class="language-text"><code>//module1.js文件
// 分别暴露
export function foo() {
  console.log('foo() module1')
}
export function bar() {
  console.log('bar() module1')
}
//module2.js文件
// 统一暴露
function fun1() {
  console.log('fun1() module2')
}
function fun2() {
  console.log('fun2() module2')
}
export { fun1, fun2 }
//module3.js文件
// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据
export default () =&gt; {
  console.log('默认暴露')
}
// app.js文件
import { foo, bar } from './module1'
import { fun1, fun2 } from './module2'
import module3 from './module3'
foo()
bar()
fun1()
fun2()
module3()
</code></pre></div><h4 id="⑤-编译并在index-html中引入">⑤ 编译并在index.html中引入</h4><ul><li>使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : <code>babel js/src -d js/lib</code></li><li>使用Browserify编译js : <code>browserify js/lib/app.js -o js/lib/bundle.js</code></li></ul><p>然后在index.html文件中引入</p><div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/lib/bundle.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p><strong>此外第三方库(以jQuery为例)如何引入呢</strong>？
首先安装依赖<code>npm install jquery@1</code>
然后在app.js文件中引入</p><div class="language- extra-class"><pre class="language-text"><code>//app.js文件
import { foo, bar } from './module1'
import { fun1, fun2 } from './module2'
import module3 from './module3'
import $ from 'jquery'

foo()
bar()
fun1()
fun2()
module3()
$('body').css('background', 'green')
</code></pre></div><h3 id="模块化总结">模块化总结</h3><ul><li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/Weblog/assets/js/app.bc17a3fe.js" defer></script><script src="/Weblog/assets/js/72.c2fad7bd.js" defer></script>
  </body>
</html>
