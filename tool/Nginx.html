<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Nginx | AlexTao 的 博客</title>
    <meta name="description" content="In doing we learn.">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/Weblog/assets/css/styles.bc17a3fe.css" as="style"><link rel="preload" href="/Weblog/assets/js/app.bc17a3fe.js" as="script"><link rel="preload" href="/Weblog/assets/js/91.391681fc.js" as="script"><link rel="prefetch" href="/Weblog/assets/css/16.styles.2339a627.css"><link rel="prefetch" href="/Weblog/assets/css/5.styles.c1152841.css"><link rel="prefetch" href="/Weblog/assets/css/7.styles.1f4a6057.css"><link rel="prefetch" href="/Weblog/assets/css/8.styles.5b6e1357.css"><link rel="prefetch" href="/Weblog/assets/js/0.a8dcd889.js"><link rel="prefetch" href="/Weblog/assets/js/10.bbae2931.js"><link rel="prefetch" href="/Weblog/assets/js/100.b8573d34.js"><link rel="prefetch" href="/Weblog/assets/js/101.abec8cfc.js"><link rel="prefetch" href="/Weblog/assets/js/102.79aa7798.js"><link rel="prefetch" href="/Weblog/assets/js/11.249c3d32.js"><link rel="prefetch" href="/Weblog/assets/js/12.6c4f9a9d.js"><link rel="prefetch" href="/Weblog/assets/js/13.9c3a7225.js"><link rel="prefetch" href="/Weblog/assets/js/14.8788763f.js"><link rel="prefetch" href="/Weblog/assets/js/15.c3d91b4b.js"><link rel="prefetch" href="/Weblog/assets/js/16.2339a627.js"><link rel="prefetch" href="/Weblog/assets/js/17.f68b5694.js"><link rel="prefetch" href="/Weblog/assets/js/18.1dc877c8.js"><link rel="prefetch" href="/Weblog/assets/js/19.8d3a8eb9.js"><link rel="prefetch" href="/Weblog/assets/js/2.adb0855b.js"><link rel="prefetch" href="/Weblog/assets/js/20.5b430c8f.js"><link rel="prefetch" href="/Weblog/assets/js/21.7570ba60.js"><link rel="prefetch" href="/Weblog/assets/js/22.c34e9396.js"><link rel="prefetch" href="/Weblog/assets/js/23.d89c70ce.js"><link rel="prefetch" href="/Weblog/assets/js/24.cc87bb5d.js"><link rel="prefetch" href="/Weblog/assets/js/25.024b7a56.js"><link rel="prefetch" href="/Weblog/assets/js/26.0d0e2118.js"><link rel="prefetch" href="/Weblog/assets/js/27.fd65c2c2.js"><link rel="prefetch" href="/Weblog/assets/js/28.e7e81b37.js"><link rel="prefetch" href="/Weblog/assets/js/29.d69a29c6.js"><link rel="prefetch" href="/Weblog/assets/js/3.9c9ae281.js"><link rel="prefetch" href="/Weblog/assets/js/30.e02a9f2a.js"><link rel="prefetch" href="/Weblog/assets/js/31.4d5d63f6.js"><link rel="prefetch" href="/Weblog/assets/js/32.2652c4b5.js"><link rel="prefetch" href="/Weblog/assets/js/33.f81118fb.js"><link rel="prefetch" href="/Weblog/assets/js/34.6539d2a9.js"><link rel="prefetch" href="/Weblog/assets/js/35.479b4b73.js"><link rel="prefetch" href="/Weblog/assets/js/36.24e9784f.js"><link rel="prefetch" href="/Weblog/assets/js/37.13a7e720.js"><link rel="prefetch" href="/Weblog/assets/js/38.57e7625b.js"><link rel="prefetch" href="/Weblog/assets/js/39.40ddc61b.js"><link rel="prefetch" href="/Weblog/assets/js/4.cb1adf5e.js"><link rel="prefetch" href="/Weblog/assets/js/40.4abade23.js"><link rel="prefetch" href="/Weblog/assets/js/41.03a22716.js"><link rel="prefetch" href="/Weblog/assets/js/42.4bf6acac.js"><link rel="prefetch" href="/Weblog/assets/js/43.7d75114c.js"><link rel="prefetch" href="/Weblog/assets/js/44.a74a0979.js"><link rel="prefetch" href="/Weblog/assets/js/45.224f0ae1.js"><link rel="prefetch" href="/Weblog/assets/js/46.716c0ee0.js"><link rel="prefetch" href="/Weblog/assets/js/47.a44c77ff.js"><link rel="prefetch" href="/Weblog/assets/js/48.c92bc6c3.js"><link rel="prefetch" href="/Weblog/assets/js/49.78d85a96.js"><link rel="prefetch" href="/Weblog/assets/js/5.c1152841.js"><link rel="prefetch" href="/Weblog/assets/js/50.65d4cc82.js"><link rel="prefetch" href="/Weblog/assets/js/51.dfe21a00.js"><link rel="prefetch" href="/Weblog/assets/js/52.a55d1d66.js"><link rel="prefetch" href="/Weblog/assets/js/53.24e5ba30.js"><link rel="prefetch" href="/Weblog/assets/js/54.3d44c9e1.js"><link rel="prefetch" href="/Weblog/assets/js/55.5509d3c1.js"><link rel="prefetch" href="/Weblog/assets/js/56.389f0044.js"><link rel="prefetch" href="/Weblog/assets/js/57.a6410cdf.js"><link rel="prefetch" href="/Weblog/assets/js/58.99de433a.js"><link rel="prefetch" href="/Weblog/assets/js/59.f362327e.js"><link rel="prefetch" href="/Weblog/assets/js/6.829d0e7e.js"><link rel="prefetch" href="/Weblog/assets/js/60.d8a731fd.js"><link rel="prefetch" href="/Weblog/assets/js/61.c32405a4.js"><link rel="prefetch" href="/Weblog/assets/js/62.2cf15697.js"><link rel="prefetch" href="/Weblog/assets/js/63.97976992.js"><link rel="prefetch" href="/Weblog/assets/js/64.df2f0acc.js"><link rel="prefetch" href="/Weblog/assets/js/65.0365fc24.js"><link rel="prefetch" href="/Weblog/assets/js/66.89f67105.js"><link rel="prefetch" href="/Weblog/assets/js/67.4d546178.js"><link rel="prefetch" href="/Weblog/assets/js/68.b3742591.js"><link rel="prefetch" href="/Weblog/assets/js/69.e2c032ec.js"><link rel="prefetch" href="/Weblog/assets/js/7.1f4a6057.js"><link rel="prefetch" href="/Weblog/assets/js/70.f262dfb0.js"><link rel="prefetch" href="/Weblog/assets/js/71.24d5a255.js"><link rel="prefetch" href="/Weblog/assets/js/72.c2fad7bd.js"><link rel="prefetch" href="/Weblog/assets/js/73.e3de86c7.js"><link rel="prefetch" href="/Weblog/assets/js/74.af039d36.js"><link rel="prefetch" href="/Weblog/assets/js/75.b5d26a4d.js"><link rel="prefetch" href="/Weblog/assets/js/76.5253b8d4.js"><link rel="prefetch" href="/Weblog/assets/js/77.13049fae.js"><link rel="prefetch" href="/Weblog/assets/js/78.732e7950.js"><link rel="prefetch" href="/Weblog/assets/js/79.91a95405.js"><link rel="prefetch" href="/Weblog/assets/js/8.5b6e1357.js"><link rel="prefetch" href="/Weblog/assets/js/80.60b08cac.js"><link rel="prefetch" href="/Weblog/assets/js/81.09852d19.js"><link rel="prefetch" href="/Weblog/assets/js/82.49b521d3.js"><link rel="prefetch" href="/Weblog/assets/js/83.681a706a.js"><link rel="prefetch" href="/Weblog/assets/js/84.ca93e702.js"><link rel="prefetch" href="/Weblog/assets/js/85.9813d878.js"><link rel="prefetch" href="/Weblog/assets/js/86.632f014f.js"><link rel="prefetch" href="/Weblog/assets/js/87.7737cd73.js"><link rel="prefetch" href="/Weblog/assets/js/88.1ec9c00d.js"><link rel="prefetch" href="/Weblog/assets/js/89.bbeb975f.js"><link rel="prefetch" href="/Weblog/assets/js/9.c685ce8f.js"><link rel="prefetch" href="/Weblog/assets/js/90.eda536dd.js"><link rel="prefetch" href="/Weblog/assets/js/92.dca04870.js"><link rel="prefetch" href="/Weblog/assets/js/93.01d44a2a.js"><link rel="prefetch" href="/Weblog/assets/js/94.f941a99a.js"><link rel="prefetch" href="/Weblog/assets/js/95.232bf755.js"><link rel="prefetch" href="/Weblog/assets/js/96.d381c6e0.js"><link rel="prefetch" href="/Weblog/assets/js/97.2a0ba8ba.js"><link rel="prefetch" href="/Weblog/assets/js/98.001e708c.js"><link rel="prefetch" href="/Weblog/assets/js/99.0ff7167d.js">
    <link rel="stylesheet" href="/Weblog/assets/css/styles.bc17a3fe.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/Weblog/" class="home-link router-link-active"><!----><span class="site-name">
      AlexTao 的 博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link router-link-active">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link router-link-active">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>Tool</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/Weblog/tool/" aria-current="page" class="sidebar-link">git</a></li><li><a href="/Weblog/tool/前端开发规范.html" class="sidebar-link">前端开发规范</a></li><li><a href="/Weblog/tool/前端工程规范.html" class="sidebar-link">前端工程规范</a></li><li><a href="/Weblog/tool/前端技术方案模板.html" class="sidebar-link">前端技术设计文档模板</a></li><li><a href="/Weblog/tool/win指令.html" class="sidebar-link">Windows 常用新建文件指令</a></li><li><a href="/Weblog/tool/MAC中设置和查看环境变量.html" class="sidebar-link">MAC中设置和查看环境变量</a></li><li><a href="/Weblog/tool/npm命令.html" class="sidebar-link">npm常用命令及包</a></li><li><a href="/Weblog/tool/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/Weblog/tool/Nginx.html" aria-current="page" class="active sidebar-link">Nginx</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#安装配置" class="sidebar-link">安装配置</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#静态服务器" class="sidebar-link">静态服务器</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#server-name-配置" class="sidebar-link">server_name 配置</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#location-配置" class="sidebar-link">location 配置</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#请求目录配置" class="sidebar-link">请求目录配置</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#访问权限控制" class="sidebar-link">访问权限控制</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#try-files" class="sidebar-link">try_files</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#gzip" class="sidebar-link">gzip</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#密码控制" class="sidebar-link">密码控制</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#轮询策略" class="sidebar-link">轮询策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#加权轮询策略" class="sidebar-link">加权轮询策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#ip-hash-策略" class="sidebar-link">ip_hash 策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#url-hash-策略" class="sidebar-link">url_hash 策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#fair-策略" class="sidebar-link">fair 策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#sticky-策略" class="sidebar-link">sticky 策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#其他参数" class="sidebar-link">其他参数</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/Nginx.html#常见处理" class="sidebar-link">常见处理</a></li></ul></li><li><a href="/Weblog/tool/echarts配置.html" class="sidebar-link">echarts 属性设置</a></li><li><a href="/Weblog/tool/错误监控.html" class="sidebar-link">错误监控</a></li><li><a href="/Weblog/tool/SEO.html" class="sidebar-link">SEO</a></li><li><a href="/Weblog/tool/util.html" class="sidebar-link">util</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="nginx">Nginx</h1><h2 id="简介">简介</h2><blockquote><p>Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。</p></blockquote><p>这里有三个词很关键，我们来拆解一下，分别是是高性能、反向代理和 web 服务器；首先这个 web 服务器自不用多说，像我们熟知的 Apache、IIS、Tomcat 等都是 web 服务器；然后是高性能，一个服务器的性能自然是网站开发者最为关心的，那么服务器的性能如何来进行衡量呢？一般可以通过 CPU 和内存的使用量来进行衡量。经过笔者简单的并发测试，在 20000 个并发链接时，CPU 和内存占用也非常低，CPU 仅占 5%，内存占用也才 2MB 不到。</p><p>我们可以通过一个 web 压力测试工具<code>Apache Bench</code>，对 Nginx 进行简单的压力测试；通过在命令行<code>ab -n 20000 -c 10000 [url]</code>，我们对 Nginx 的首页发起请求总数为 20000，并发数为 10000 的请求测试，测试结果如下：</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/ab.png" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/ab.png" alt="压力测试结果"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/ab.png" target="_blank" rel="noopener noreferrer">压力测试结果<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>我们看到总的请求时间（Time taken for tests）是 25 秒，平均每个请求耗时（Time per request）1.25 毫秒，在这么高的并发量下面，服务器响应性能还是挺不错的。</p><p>然后是反向代理，与之对应的就是正向代理，这两者的区别也是面试中经常被问到的。我们先来看一下什么是正向代理，一个正向代理最典型的例子就是我们常用的“梯子”。</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/catch.png" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/catch.png" alt="表情包"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/catch.png" target="_blank" rel="noopener noreferrer">表情包<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>我们直接访问 Google，是访问不到的，但是如果我们使用了代理服务器，那么通过访问代理服务器就可以浏览 Google，这里的代理服务器就属于<code>正向代理</code>；通过正向代理我们可以访问原来无法访问的资源。</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/positive-proxy.jpg" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/positive-proxy.jpg" alt="正向代理"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h3 id="正向代理"><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/positive-proxy.jpg" target="_blank" rel="noopener noreferrer">正向代理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>那么什么是反向代理呢？反向代理最典型的例子就是我们的 Nginx 服务器了；比如我们在访问某个网站时，由代理服务器去目标服务器获取数据后返回给客户端，这样就能够隐藏真实服务器的 IP 地址，只对外开放代理服务器，以防止外网对内网服务器的恶性攻击。</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/negative-proxy.jpg" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/negative-proxy.jpg" alt="反向代理"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h3 id="反向代理"><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/negative-proxy.jpg" target="_blank" rel="noopener noreferrer">反向代理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>理解了上面两个典型的案例，相信大家对正向反向代理也了解了，我们总结一下：</p><ul><li>正向代理，<strong>代理客户端</strong>，服务端不知道实际发起请求的客户端。</li><li>反向代理，<strong>代理服务端</strong>，客户端不知道实际提供服务的服务端。</li></ul><h2 id="安装配置">安装配置</h2><p>Nginx 安装程序分为 Linux 版和 Windows 版，Windows 版本的 Nginx 下载解压后就可以直接运行了，而 Linux 版本的需要 make、configure 等命令编译安装，好处是可以方便灵活的编译不同的模块到 Nginx；网上也有很多的安装教程，这里就不再赘述了，可以从<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener noreferrer">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载适合自己的版本，下载好后我们来看一下他的目录结构：</p><div class="language- extra-class"><pre class="language-text"><code>├── conf            #所有配置文件的目录
    ├── nginx.conf  #主配置文件
    ├── mime.types  #媒体类型控制文件
├── contrib         #存放一些实用工具
├── docs            #文档资料
├── html            #默认解析的静态文件目录
├── logs            #日志目录
├── sbin            #启动运行程序
</code></pre></div><p>我们经常用到的就是 conf 目录和 html 目录；而在根目录可以运行常用的一些命令对 Nginx 进行操作控制：</p><div class="language- extra-class"><pre class="language-text"><code>nginx -s reopen 	#重启Nginx
nginx -s reload 	#重新加载Nginx配置文件，然后以优雅的方式重启Nginx
nginx -s stop   	#强制停止Nginx服务
nginx -s quit   	#优雅地停止Nginx服务（即处理完所有请求后再停止服务）
nginx -h 		    #打开帮助信息
nginx -v 		    #显示版本信息并退出
nginx -V		    #显示版本和配置选项信息，然后退出
nginx -t		    #检测配置文件是否有语法错误，然后退出
nginx -T	 	    #检测配置文件是否有语法错误，转储并退出
nginx -q 	  	    #在检测配置文件期间屏蔽非错误信息
nginx -p prefix   	#设置前缀路径(默认是:/usr/share/nginx/)
nginx -c filename	#设置配置文件(默认是:/etc/nginx/nginx.conf)
nginx -g directives #设置配置文件外的全局指令
killall nginx		#杀死所有nginx进程
</code></pre></div><p>我们看前四个命令会发现，这四个命令可以分为两种，重启和停止 Nginx，不过一种是强制的方式，另一种是优雅的方式；强制的方式就是让 Nginx 立即停止当前处理的所有请求，丢弃链接，停止工作；而优雅的方式是允许 Nginx 将当前正在处理的请求处理完成，但是不再接收新的请求，所有处理完成后再停止工作。</p><p>我们再来看一下主要配置文件 nginx.conf 的基本结构：</p><div class="language- extra-class"><pre class="language-text"><code># nginx进程数，建议设置为等于CPU总核心数
worker_processes  1;
# 进程文件
pid        logs/nginx.pid;
# 单个进程最大连接数
events {
    worker_connections  1024;
}
http {
    # 文件扩展名与类型映射表
    include       mime.types;
    # 默认文件类型
    default_type  application/octet-stream;
    # 开启gzip压缩
    gzip  on;
    sendfile        on;
    keepalive_timeout  65;
    server {
        # 监听端口
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
}
</code></pre></div><p>配置文件中主要可以分为以下几个块：</p><ul><li>全局模块：从配置文件开始到 events 块之间的内容，此处的配置影响 nginx 服务器整体的运⾏，⽐如 worker 进程的数量、错误⽇志的位置等</li><li></li></ul><ul><li>events：配置影响 nginx 服务器或与用户的网络连接。</li><li>http：<strong>可以嵌套多个 server</strong>，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。</li><li>server：配置虚拟主机的相关参数，一个 http 中可以有多个 server。</li><li>location：配置请求的路由，以及各种页面的处理情况。</li></ul><p>很多时候，我们不会将所有的配置全都写在一个主配置文件，因为这样会显得冗长，也不知道每个模块是做什么用的；而是会根据项目来拆分多个配置文件，每个配置文件彼此独立，互不干扰，然后在主配置文件中引入；我们在 conf 目录下新建一个 projects 目录，然后可以新建多个.conf 配置文件：</p><div class="language- extra-class"><pre class="language-text"><code># /conf/projects/home.conf
server {
    listen       8080;
    server_name  localhost;
    location / {
        root   html;
        index  index.html index.htm;
    }
}
server {
    listen       8081;
    server_name  localhost;
    location / {
        root   html;
        index  index.html index.htm;
    }
}
</code></pre></div><p>然后在主配置 nginx.conf 中将 projects 目录下的所有配置文件引入：</p><div class="language- extra-class"><pre class="language-text"><code>http {
    include       mime.types;
    default_type  application/octet-stream;
    gzip  on;
    sendfile        on;
    keepalive_timeout  65;
    ## 引入projects目录下所有的配置文件
    include       projects/*.conf;
}
</code></pre></div><p>这样我们可以直接在 projects 目录下新增.conf 后缀的配置文件，而不用修改主配置文件；但是我们修改完还不能确定是否会有错误，可以通过命令对配置文件进行检测：</p><div class="language- extra-class"><pre class="language-text"><code>nginx -t
#nginx: the configuration file nginx/conf/nginx.conf syntax is ok
#nginx: configuration file nginx/conf/nginx.conf test is successful
</code></pre></div><p>通过检测发现没有任何报错，就可以优雅的重启服务器了：</p><div class="language- extra-class"><pre class="language-text"><code>nginx -s reload
</code></pre></div><h2 id="静态服务器">静态服务器</h2><p>作为一个 web 服务器，最重要的就是能够对静态资源提供访问服务，我们的 Nginx 服务器可以用来托管一些静态的资源，比如 js、css、图片等，访问某一特定的静态资源路径时会转发到本地目录文件上；那么我们就来看 Nginx 是如何一步一步的通过域名配置、URI 配置以及目录配置来命中请求的。</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/welcome.png" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/welcome.png" alt="Nginx首页"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/welcome.png" target="_blank" rel="noopener noreferrer">Nginx 首页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h2 id="server-name-配置">server_name 配置</h2><p>在上面的配置中，我们主要是将<code>server_name</code>设置为<code>localhost</code>，但是这样仅能让局域网内的主机访问到；我们想要让广域网上的其他主机访问，可以将<code>server_name</code>匹配域名，它的参数值可以是以下几种：</p><ul><li>精确的域名，如<a href="http://www.my.com/" target="_blank" rel="noopener noreferrer">www.my.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li></li></ul><ul><li>通配符名称，但通配符只能用在由三段字符串组成的名称的首段或尾段，如<code>*.my.com或者www.my.*</code></li><li>正则表达式，使用波浪号<code>~</code>作为正则表达式字符串的开始标记，如<code>~^www\d+\.my\.com$</code></li><li>ip 地址</li></ul><p>在上面正则表达式中，<code>^</code>表示以 www 开头，紧跟一个或多个数字（\d+），然后跟上域名 my.com，最后以<code>$</code>结尾；因此上面的表达式可以匹配的域名比如 www1.my.com，但是<a href="http://www.my.xn--com-928dl06dwp4d./" target="_blank" rel="noopener noreferrer">www.my.com 就不行。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>正则表达式还支持字符串捕获功能，即将正则表达式匹配成功的名称中的一部分字符串截取出来，放在变量中供后面使用；比如将 server_name 进行如下设置：</p><div class="language- extra-class"><pre class="language-text"><code>server {
  listen       80;
  server_name  ~^(.+)?\.my\.com$;
  location / {
    root   /usr/share/nginx/html/$1;
    index  index.html index.htm;
  }
}
</code></pre></div><p>这样，通过二级域名 home.my.com 到达 Nginx 时，被<code>server_name</code>正则表达式捕获，将其中的<code>home</code>字符串存入<code>$1</code>变量中，我们在<code>/usr/share/nginx/html/home</code>目录下的静态资源就能通过 home.my.com 域名来访问了；我们服务器的目录就可以是这样的：</p><div class="language- extra-class"><pre class="language-text"><code>/usr/share/nginx/html/
    |- home
        |- index.html
    |- blog
        |- index.html
    |- mail
        |- index.html
    |- photo
        |- index.html
</code></pre></div><p>这样就只需要一个 server 块来完成多个站点的配置。</p><p>nginx 允许一个虚拟主机有多个域名，因此我们可以给 server_name 同时配置多个域名，多个之间以空格分隔：</p><div class="language- extra-class"><pre class="language-text"><code>server {
  listen       80;
  server_name  a.com b.com c.com;
  # ...其他配置
}
</code></pre></div><p>由于 server_name 支持以上三种配置方式，如果出现多个 server 块同时匹配了相同的域名，那么这个请求交给哪个 server 呢？因此优先级顺序如下：</p><ol><li>精确匹配 server_name</li><li>通配符在开始时匹配 server_name</li><li>通配符在结尾时匹配 server_name</li><li>正则表达式匹配 server_name</li></ol><p>如果我们想让局域网内的设备访问 nginx，可以将<code>server_name</code>设置 ip 地址的方式：</p><div class="language- extra-class"><pre class="language-text"><code>server {
  listen       80;
  server_name  localhost 192.168.1.101;
}
</code></pre></div><p>如果还不能访问，可以查看下是否是防火墙的原因，在防火墙允许通过的应用中将 Nginx 勾选（没有找到 Nginx 可以点击<code>允许其他应用</code>进行新增）：</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/fireware.png" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/fireware.png" alt="Windows防火墙"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/fireware.png" target="_blank" rel="noopener noreferrer">Windows 防火墙<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>有时候我们还会见到将 server*name 设置为<code>*</code>（下划线），意味着 server_name 为空，即匹配全部的主机；我们可以配置 host，将 a.com、b.com 和 c.com 都指向本机，然后配置 nginx：</p><div class="language- extra-class"><pre class="language-text"><code>server {
  listen       80;
  server_name  _;
  location / {
    root   html;
    index  index.html index.htm;
  }
}
</code></pre></div><p>这样我们不仅可以通过域名 a.com、b.com、c.com 来访问，也能通过 ip 的方式。</p><h2 id="location-配置">location 配置</h2><p>location 用于匹配不同的 URI 请求，它的语法如下：</p><div class="language- extra-class"><pre class="language-text"><code>location [ = | ~ | ~* | ^~ ] uri { ... }
location @/name/ { … }
</code></pre></div><p>这里的<code>uri</code>就是待匹配的请求字符串，可以是不含正则的字符串，比如<code>/home</code>，称为<code>标准URI</code>；也可以是包含正则的字符串，比如<code>\.html$</code>（表示以.html 结尾），称为<code>正则URI</code>。而方括号中的四种匹配符都是可选的，用来改变请求字符串与 URI 的匹配方式，我们来看下四种匹配符的解释：</p><table><thead><tr><th>匹配符</th><th>解释</th></tr></thead><tbody><tr><td>不填</td><td>location 后没有参数，直接跟着标准 URI，表示前缀匹配，代表跟请求中的 URI 从头开始匹配</td></tr><tr><td>=</td><td>用于标准 URI 前，要求请求字符串与其精准匹配，成功则立即处理，nginx 停止搜索其他匹配</td></tr><tr><td>^~</td><td>用于标准 URI 前，要求一旦匹配就会立即处理，不再去匹配其他正则 URI，一般用来匹配目录</td></tr><tr><td>~</td><td>用于正则 URI 前，表示 URI 包含正则表达式，<code>区分大小写</code></td></tr><tr><td>~*</td><td>用于正则 URI 前，表示 URI 包含正则表达式，<code>不区分大小写</code></td></tr><tr><td>@</td><td>定义一个命名的 location，@定义的 location 名字一般用在内部定向</td></tr></tbody></table><p>我们来看下每种匹配规则能匹配的 url，首先不填代表的话表示前缀匹配，如果我们有多个相似的前缀匹配：</p><div class="language- extra-class"><pre class="language-text"><code>location /pre/fix {
  # ...
}
location /pre {
  # ...
}
</code></pre></div><p>对于请求<code>/pre/fix/home</code>，根据最大匹配原则，匹配第一个 location。</p><p>然后是<code>=</code>，要求路径完全匹配：</p><div class="language- extra-class"><pre class="language-text"><code>location = /abc {
  # ...
}

# /abc    匹配
# /abcde  不匹配
# /abc/   不匹配，带有结尾的/
# /cde/abc不匹配
</code></pre></div><p>其次是<code>^~</code>最佳匹配，它的优先级高于正则表达式：</p><div class="language- extra-class"><pre class="language-text"><code>location ^~ /login {
  # ...
}

# /login      匹配
# /loginss    匹配
# /login/     匹配
# /home/login 不匹配
</code></pre></div><p>接着是<code>~</code>正则表达式匹配，它区分大小写匹配（注意：windows 版本 nginx 不区分）：</p><div class="language- extra-class"><pre class="language-text"><code>location ~ \.(gif|jpg|png|js|css)$ {
  # ...
}
# /bg.png     匹配
# /bg.PNG     不匹配
# /bg.png?a=1 匹配
# /bg.jpeg    不匹配
</code></pre></div><p><code>~*</code>同样也是正则匹配，只不过它不区分大小写，这里就不再演示。</p><p>如果我们的 URI 匹配到了多个 location，其并不完全按照在配置文件中出现的顺序来进行匹配，URI 会按照如下规则进行匹配：</p><ol><li>= 精确匹配会第一个被处理。如果发现精确匹配，nginx 停止搜索其他匹配。</li><li></li></ol><ol start="3"><li>普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。</li><li>^~ 则只匹配该规则，nginx 停止搜索其他匹配，否则 nginx 会继续处理其他 location 指令。</li><li>最后匹配理带有<code>~</code>和<code>~*</code>的指令，如果找到相应的匹配，则 nginx 停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。</li></ol><h2 id="请求目录配置">请求目录配置</h2><p>在 location 匹配 URI 后，就需要在服务器指定的目录中寻找请求资源，而<code>root</code>和<code>alias</code>就是用来指定目录的两种指令，两者主要的区别在于如何解析 location 后面的路径；我们首先来看下 root 的用法，假如我们需要将<code>/data/</code>下面的所有路径转发到<code>html/roottest</code>下面：</p><div class="language- extra-class"><pre class="language-text"><code>location /data/ {
  root html/roottest;
}
</code></pre></div><p>当 location 接收到<code>/data/index.html</code>的请求时，会在<code>html/roottest/data/</code>目录下找到 index.html 文件并进行相应，root 会将 root 路径和 location 路径进行拼接。</p><p>而 alias 指令则改变 location 接收到的请求路径，假如我们需要将<code>/data1/</code>下面的所有路径转发到<code>html/aliastest</code>下面：</p><div class="language- extra-class"><pre class="language-text"><code>location /data1/ {
  alias html/aliastes/;
}
</code></pre></div><p>当 location 接收到<code>/data1/index.html</code>的请求时，会在<code>html/aliastes/</code>目录下查找 index.html 文件并响应。</p><blockquote><p>需要注意的是：alias 指令后面的路径<code>必须以/结束</code>，否则会找不到文件，而 root 则可有可无。</p></blockquote><h2 id="访问权限控制">访问权限控制</h2><p>针对一些静态资源，我们可能会设置一些用户访问权限，比如和 js 一起打包产出的<code>.map</code>文件，会对源码进行映射；但是我们想让它只能针对公司的 ip 进行开放，对外网的 ip 禁止访问，这时就需要用到<code>allow</code>和<code>deny</code>命令了。</p><p>假如局域网还有两个设备，我们只能让这两个设备的 ip 通过访问：</p><div class="language- extra-class"><pre class="language-text"><code>location / {
  alias html/aliastes/;
  allow 192.168.1.102;
  allow 192.168.1.103;
  deny all;
}
</code></pre></div><p>deny 和 allow 指令是由 ngx_http_access_module 模块提供，Windows 版本的 Nginx 并不包含该模块。</p><p>还可以对前端的.map 文件进行访问权限控制，打包后的 map 文件一般会放在服务器上，但是如果能对所有人开放，别人就能查看到对应源码；因此我们可以控制只有公司的 ip 才有访问权限：</p><h2 id="try-files">try_files</h2><p>前端在配置路由时经常会用到 history 路由模式，因此后台就需要映射对应的路由到 index.html；但是如果我们给每个路由都配置一个 location 就会比较繁琐，因此可以通过<code>try_files</code>指令来进行尝试解析；<code>try_files</code>的语法规则如下：</p><div class="language- extra-class"><pre class="language-text"><code># 格式1：
try_files file ... uri;
# 格式2：
try_files file ... =code;
</code></pre></div><p>假设我们打包出来的单页面位于<code>/html/my/index.html</code>，我们想要将/login、/regisrer 等路由指向 index.html，我们可以配置 try_files：</p><div class="language- extra-class"><pre class="language-text"><code>server {
    listen       8080;
    server_name  localhost;
    location / {
        try_files $uri /my/index.html;
    }
}
</code></pre></div><p>对于多页面的应用，假设我们的页面都放在<code>/html/pages/</code>目录下，我们想要访问<code>/login</code>时响应<code>/html/pages/login.html</code>页面，可以通过<code>$uri</code>：</p><div class="language- extra-class"><pre class="language-text"><code>server {
    listen       8080;
    server_name  localhost;
    location / {
        index  index.html index.htm;
        root html/pages;
        try_files $uri /$uri.html $uri/index.html /index.html;
    }
}
</code></pre></div><p>这里我们设置 root 目录为 html/pages，当我们访问<code>/login</code>路由时，这里的$uri 就是/login，try_files 会去尝试在根目录下找<code>/login.html</code>；如果找不到就尝试<code>/login/index.html</code>，最后找不到则会默认返回 index.html。</p><h2 id="gzip">gzip</h2><p>我们都知道在服务端开启 gzip 压缩能够使得 js、css、html 等文件在传输时大幅提高访问速度，优化网站性能；gzip 压缩后的文件大小可以变为原来的 30%甚至更小；而对于图片、视频、音频等其他多媒体文件，因为压缩效果不好，所以不会开启压缩。</p><p>gzip 压缩本质上是服务器端压缩，传输到浏览器后解压解析，我们来看下 gzip 的原理示意：</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/gzip.jpg" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/gzip.jpg" alt="Gzip原理"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/gzip.jpg" target="_blank" rel="noopener noreferrer">Gzip 原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>可以看到在请求和相应头上分别加了 accept-encoding 和 content-encoding 来进行传输；我们可以通过一个 js 的请求数据来查看：</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/gzip-header.png" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/gzip-header.png" alt="Gzip请求响应头"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/gzip-header.png" target="_blank" rel="noopener noreferrer">Gzip 请求响应头<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>既然 gzip 有这么多的好处，我们来看下 nginx 如何进行配置，gzip 的配置可以在 http 块或者 server 块中：</p><div class="language- extra-class"><pre class="language-text"><code># 开启gzip
gzip        on;
# 设置gzip申请内存的大小
gzip_buffers 32 4K;
# 设置gzip压缩等级
# 压缩级别 1-9，级别越高压缩率越大但耗CPU
gzip_comp_level 6;
# 正则匹配User-Agent中的值，匹配上则不进行gzip
gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;
# 设置允许压缩的页面最小字节数
gzip_min_length 1024;
# 设定进行gzip压缩的最小http版本
gzip_http_version 1.0;
# 需要压缩哪些响应类型的资源
gzip_types application/javascript text/css text/xml;
# 添加“Vary: Accept-Encoding”响应头
gzip_vary on;
</code></pre></div><h2 id="密码控制">密码控制</h2><p>对于一些简单的页面，我们想要通过密码来限制其他用户的访问，但是又不想接入复杂的账号体系，Nginx 提供了简单的账号密码控制；首先我们通过 Linux 的工具创建一个密码本存放账号密码：</p><div class="language- extra-class"><pre class="language-text"><code>sudo yum install httpd-tools -y
sudo htpasswd -c passwd/passwd admin
</code></pre></div><p><code>passwd/passwd</code>文件就是生成的密码文件，运行后会要求连续两次输入密码，成功后为 admin 用户添加了密码；然后我们就修改 nginx 的配置文件，对站点开启密码验证：</p><div class="language- extra-class"><pre class="language-text"><code>server {
  listen 8000;
	server_name localhost;
	auth_basic &quot;请输入账号密码&quot;;
	auth_basic_user_file /etc/nginx/conf/passwd/passwd;
	location / {
    # .....
	}
}
</code></pre></div><p>重启 nginx，再次访问站点就会出现需要身份验证的弹框了。</p><h1 id="反向代理-2">反向代理</h1><p>上面我们介绍了正向代理和反向代理的区别，反向代理功能是 nginx 的三大主要功能之一（静态 web 服务器、反向代理、负载均衡）。反向代理不需要额外的模块，默认自带 proxy_pass 和 fastcgi_pass 指令，通过在 location 块中配置即可实现：</p><div class="language- extra-class"><pre class="language-text"><code>server {
  listen 80;
  server_name a.com;
  location / {
    proxy_pass http://192.168.1.102:8080;
  }
}
</code></pre></div><p>在配置 proxy_pass 时，我们需要注意 url 后面的<code>/</code>；当我们通过下面几种情况访问`/proxy/home.html``时：</p><div class="language- extra-class"><pre class="language-text"><code>location /proxy/ {
  proxy_pass http://192.168.1.102:8080/;
}
</code></pre></div><p>第一种情况 url 后面带上/，则会被代理到<code>http://192.168.1.102:8080/home.html</code>。</p><div class="language- extra-class"><pre class="language-text"><code>location /proxy/ {
  proxy_pass http://192.168.1.102:8080;
}
</code></pre></div><p>第二种情况 url 后不带/，则会被代理到<code>http://192.168.1.102:8080/proxy/home.html</code></p><div class="language- extra-class"><pre class="language-text"><code>location /proxy/ {
  proxy_pass http://192.168.1.102:8080/doc/;
}
</code></pre></div><p>第三种情况代理/doc/，则会被代理到<code>http://192.168.1.102:8080/doc/home.html</code></p><div class="language- extra-class"><pre class="language-text"><code>location /proxy/ {
  proxy_pass http://192.168.1.102:8080/doc;
}
</code></pre></div><p>第四种情况代理/doc，则会被代理到<code>http://192.168.1.102:8080/dochome.html</code></p><p>在配置反向代理时，我们还可以修改代理请求的请求参数：</p><div class="language- extra-class"><pre class="language-text"><code>location /proxy/ {
  proxy_pass http://192.168.1.102:8080/;
  # 修改请求的method
  proxy_method GET;
  # 修改请求的http协议版本
  proxy_http_version 1.1;
  # 将原来host字段放到转发请求中
  proxy_set_header Host $host;
  #获取真实ip
  proxy_set_header X-Real-IP $remote_addr;
  # 代理服务器每成功收到一个请求，就把请求来源IP地址添加到右边
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_redirect  off;
}
</code></pre></div><p>经过反向代理后，由于客户端和 web 服务器之间增加了一个代理层，因此 web 服务器无法拿到客户端请求的 host 和真实 ip，我们通过 proxy_set_header 指令修改代理请求的头部；host和remote_addr 是用户真实的 host 和 ip，这里作为变量传入 Host 和 X-Real-IP 字段，因此我们在客户端服务器想要获取真实 ip 就可以通过 request.getAttribute(“X-real-ip”)的方式。</p><h1 id="负载均衡">负载均衡</h1><p>随着互联网的发展，用户规模的增加，服务器的压力也越来越大，如果只使用一台服务器有时候不能承受流量的压力，这时我们就需要将部分流量分散到多台服务器上，使得每台服务器都均衡的承担压力。</p><p>nginx 负载均衡目前支持六种策略：轮询策略、加权轮询策略、ip_hash 策略、url_hash 策略、fair 策略和 sticky 策略；六种策略可以分为两大类，内置策略（轮询、加权轮询、ip_hash）和扩展策略（url_hash、fair、sticky）；默认情况下内置策略自动编译在 Nginx 中，而扩展策略需要额外安装。</p><p>既然是负载，那么我们需要启用多台服务器；这里为了方便演示，我们在一台电脑上运行 node 脚本来模拟 3 台服务器；同时为了方便看到每台服务器有多少流量，每访问一次就计数一次：</p><div class="language- extra-class"><pre class="language-text"><code>const express = require(&quot;express&quot;);
const app = express();
const PORT = 8080;
const path = require(&quot;path&quot;);
let count = 0;
app.get(&quot;*&quot;, (req, res) =&gt; {
  count++;
  res.sendFile(path.resolve(__dirname, &quot;./index.html&quot;));
});
app.listen(PORT);
</code></pre></div><p>然后我们修改端口号，这样我们就有 8080、8081、8082 三个服务器了。</p><h2 id="轮询策略">轮询策略</h2><p>轮询策略，顾名思义，就是按照请求顺序，逐一分配到不同的服务器节点；如果某台服务器出现问题，会自动剔除。</p><div class="language- extra-class"><pre class="language-text"><code>upstream myserver {
    server 192.168.1.101:8080;
    server 192.168.1.101:8081;
    server 192.168.1.101:8082;
}
server {
    listen      8070;
    server_name _;
    location / {
        proxy_pass http://myserver;
    }
}
</code></pre></div><p>我们还是通过测试工具<code>Apache Bench</code>来并发 100 个请求到 Nginx：</p><div class="language- extra-class"><pre class="language-text"><code>ab -n 100 -c 10 http://localhost:8070/
</code></pre></div><p>最后统计每台服务器的结果，每台服务器的请求还是很平均的：</p><div class="language- extra-class"><pre class="language-text"><code>8080：34个请求
8081：33个请求
8082：33个请求
</code></pre></div><h2 id="加权轮询策略">加权轮询策略</h2><p>加权轮询在基本轮询策略上考虑各服务器节点接受请求的权重，指定服务器节点被轮询的权重，主要用于服务器节点性能不均的情况。</p><p>通过在 server 节点后配置 weight 来设置权重，weight 的大小和访问比率成正比（weight 的默认值为 1）；我们给三台服务器设置访问比是<code>1:3:2</code>。</p><div class="language- extra-class"><pre class="language-text"><code>upstream myserver {
    server 192.168.1.101:8080;
    server 192.168.1.101:8081 weight=3;
    server 192.168.1.101:8082 weight=2;
}
</code></pre></div><p>压力测试后统计服务器的请求结果，和我们配置的比率还是几乎相同的：</p><div class="language- extra-class"><pre class="language-text"><code>8080：16个请求
8081：51个请求
8082：33个请求
</code></pre></div><blockquote><p>注：由于 weight 是内置，所以可以直接和其他策略配合使用。</p></blockquote><h2 id="ip-hash-策略">ip_hash 策略</h2><p>ip_hash 策略是将前端访问的 ip 进行 hash 操作后，然后根据 hash 的结果将请求分配到不同的节点上，这样使得每个 ip 都会固定访问服务节点；这样做的好处是用户的 session 只在一个后端服务器节点上，不必考虑一个 session 存在多台服务器节点出现 session 共享问题。</p><div class="language- extra-class"><pre class="language-text"><code>upstream myserver {
    ip_hash;
    server 192.168.1.101:8080;
    server 192.168.1.101:8081 weight=3;
    server 192.168.1.101:8082 weight=2;
}
</code></pre></div><p>压力测试后统计服务器的请求结果，我们发现所有的请求都到固定一台服务器上了：</p><div class="language- extra-class"><pre class="language-text"><code>8080：0个请求
8081：0个请求
8082：100个请求
</code></pre></div><h2 id="url-hash-策略">url_hash 策略</h2><p>url_hash 策略是将 url 地址进行 hash 操作，根据 hash 结果请求定向到同一服务器节点上；url_hash 的优点是能够提高后端缓存服务器的效率。</p><div class="language- extra-class"><pre class="language-text"><code>upstream myserver {
    hash $request_uri;
    server 192.168.1.101:8080;
    server 192.168.1.101:8081;
    server 192.168.1.101:8082;
}
</code></pre></div><p>压力测试后统计服务器的请求结果：</p><div class="language- extra-class"><pre class="language-text"><code>8080：0个请求
8081：0个请求
8082：100个请求
</code></pre></div><p>如果我们切换不同的 url，/home、/list 等，都会分配到不同的服务器节点。</p><h2 id="fair-策略">fair 策略</h2><p>fair 策略请求转发到负载最小的后端服务器节点上。Nginx 通过服务器节点对响应时间来判断负载情况，响应时间最短的节点负载就相对较轻，Nginx 就会将前端请求转发到此服务器节点上。</p><blockquote><p>注：fair 策略默认不被编译进 nginx 内核，需要额外安装</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>upstream myserver {
    fair;
    server 192.168.1.101:8080;
    server 192.168.1.101:8081;
    server 192.168.1.101:8082;
}
</code></pre></div><p>压力测试后统计服务器的请求结果：</p><div class="language- extra-class"><pre class="language-text"><code>8080：33个请求
8081：33个请求
8082：34个请求
</code></pre></div><h2 id="sticky-策略">sticky 策略</h2><p>sticky 策略是基于 cookie 的一种负载均衡解决方案，通过分发和识别 cookie，使来自同一个客户端的请求落在同一台服务器上，默认 cookie 标识名为 route。</p><p>sticky 策略看起来和 ip_hash 策略类似，但是又有一定区别。假设在一个局域网内有 3 台电脑，他们有 3 个内网 IP，但是他们发起请求时，却只有一个外网 IP，如果使用 ip_hash 方式，则 Nginx 会将请求分配到同一服务器；如果使用 sticky 策略，则会把请求分配到不同服务器上，这是 ip_hash 无法做到的。</p><blockquote><p>注：sticky 策略默认不被编译进 nginx 内核，需要额外安装</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>upstream myserver {
    sticky name=sticky_cookie expires=6h;
    server 192.168.1.101:8080;
    server 192.168.1.101:8081;
    server 192.168.1.101:8082;
}
</code></pre></div><p>sticky 默认的 cookie 的名称是<code>route</code>，我们可以通过 name 修改，还有一些其他的 cookie 参数可以进行修改：</p><ul><li>[name=route]　　　　　　　设置用来记录会话的 cookie 名称</li><li>[domain=.foo.bar]　　　　设置 cookie 作用的域名</li><li>[path=/]　　　　　　　　 设置 cookie 作用的 URL 路径，默认根目录</li><li></li></ul><ul><li>[expires=1h] 　　　　　　 设置 cookie 的生存期，默认不设置，浏览器关闭即失效</li><li>[hash=index|md5|sha1] 设置 cookie 中服务器的标识是用明文还是使用 md5 值，默认使用 md5</li><li>[no_fallback]　　　　　　 设置该项，当 sticky 的后端机器挂了以后，nginx 返回 502 (Bad Gateway or Proxy Error) ，而不转发到其他服务器，不建议设置</li><li>[secure]　　　　　　　　 设置启用安全的 cookie，需要 HTTPS 支持</li><li>[httponly]　　　　　　　 允许 cookie 不通过 JS 泄漏，没用过</li></ul><p>我们通过浏览器来访问，在 cookie 中可以看到 sticky 下发的 cookie</p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/sticky.png" target="_blank" rel="noopener noreferrer"><img src="https://qiniu.xieyufei.com/blog/Front-Nginx/sticky.png" alt="sticky策略cookie"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://qiniu.xieyufei.com/blog/Front-Nginx/sticky.png" target="_blank" rel="noopener noreferrer">sticky 策略 cookie<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><blockquote><p>注：由于 cookie 最初由服务器端下发，如果客户端禁用 cookie，则 cookie 不会生效。</p></blockquote><h2 id="其他参数">其他参数</h2><p>upstream 还有一些参数我们可以配合负载均衡：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fail_timeout</td><td>与 max_fails 结合使用</td></tr><tr><td>max_fails</td><td>设置在 fail_timeout 参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了</td></tr><tr><td>fail_time</td><td>服务器会被认为停机的时间长度,默认为 10s。</td></tr><tr><td>backup</td><td>标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里。</td></tr><tr><td>down</td><td>标记服务器永久停机了。</td></tr><tr><td>keepalive</td><td>连接数（keepalive 的值）指定了每个工作进程中保留的持续连接到 nginx 负载均衡器缓存的最大值。如果超过这个设置值的闲置进程想链接到 nginx 负载均衡器组，最先连接的将被关闭。</td></tr></tbody></table><div class="language- extra-class"><pre class="language-text"><code>upstream backserver{
  ip_hash;
  # down 表示单前的server暂时不参与负载
  server 192.168.1.101:8080 down;
  server 192.168.1.101:8081;
  # max_fails允许请求失败的次数默认为1，此处允许失败的次数为3。每次失败后暂停的时间为30s
  server 192.168.1.101:8082 max_fails=3 fail_timeout=30s;
  # 其它所有的非backup机器down或者忙的时候，请求backup机器
  server 192.168.1.101:8083 backup;
  # 连接到nginx负载均衡器的最大
  keepalive 16;
}
</code></pre></div><h2 id="常见处理">常见处理</h2><div class="language- extra-class"><pre class="language-text"><code>base建议设置为如下，就可以部署在服务器任意目录了
base: './',

nginx
location /project {
	# 服务器项目包位置
	alias     /home/application/dist;
	index     index.html;
}
</code></pre></div></div><div class="page-edit"><!----><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/Weblog/tool/webpack.html" class="prev">
          webpack
        </a></span><span class="next"><a href="/Weblog/tool/echarts配置.html">
          echarts 属性设置
        </a> →
      </span></p></div></div></div></div>
    <script src="/Weblog/assets/js/app.bc17a3fe.js" defer></script><script src="/Weblog/assets/js/91.391681fc.js" defer></script>
  </body>
</html>
