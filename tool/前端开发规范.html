<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端开发规范 | AlexTao 的 博客</title>
    <meta name="description" content="In doing we learn.">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/Weblog/assets/css/styles.bc17a3fe.css" as="style"><link rel="preload" href="/Weblog/assets/js/app.bc17a3fe.js" as="script"><link rel="preload" href="/Weblog/assets/js/100.b8573d34.js" as="script"><link rel="prefetch" href="/Weblog/assets/css/16.styles.2339a627.css"><link rel="prefetch" href="/Weblog/assets/css/5.styles.c1152841.css"><link rel="prefetch" href="/Weblog/assets/css/7.styles.1f4a6057.css"><link rel="prefetch" href="/Weblog/assets/css/8.styles.5b6e1357.css"><link rel="prefetch" href="/Weblog/assets/js/0.a8dcd889.js"><link rel="prefetch" href="/Weblog/assets/js/10.bbae2931.js"><link rel="prefetch" href="/Weblog/assets/js/101.abec8cfc.js"><link rel="prefetch" href="/Weblog/assets/js/102.79aa7798.js"><link rel="prefetch" href="/Weblog/assets/js/11.249c3d32.js"><link rel="prefetch" href="/Weblog/assets/js/12.6c4f9a9d.js"><link rel="prefetch" href="/Weblog/assets/js/13.9c3a7225.js"><link rel="prefetch" href="/Weblog/assets/js/14.8788763f.js"><link rel="prefetch" href="/Weblog/assets/js/15.c3d91b4b.js"><link rel="prefetch" href="/Weblog/assets/js/16.2339a627.js"><link rel="prefetch" href="/Weblog/assets/js/17.f68b5694.js"><link rel="prefetch" href="/Weblog/assets/js/18.1dc877c8.js"><link rel="prefetch" href="/Weblog/assets/js/19.8d3a8eb9.js"><link rel="prefetch" href="/Weblog/assets/js/2.adb0855b.js"><link rel="prefetch" href="/Weblog/assets/js/20.5b430c8f.js"><link rel="prefetch" href="/Weblog/assets/js/21.7570ba60.js"><link rel="prefetch" href="/Weblog/assets/js/22.c34e9396.js"><link rel="prefetch" href="/Weblog/assets/js/23.d89c70ce.js"><link rel="prefetch" href="/Weblog/assets/js/24.cc87bb5d.js"><link rel="prefetch" href="/Weblog/assets/js/25.024b7a56.js"><link rel="prefetch" href="/Weblog/assets/js/26.0d0e2118.js"><link rel="prefetch" href="/Weblog/assets/js/27.fd65c2c2.js"><link rel="prefetch" href="/Weblog/assets/js/28.e7e81b37.js"><link rel="prefetch" href="/Weblog/assets/js/29.d69a29c6.js"><link rel="prefetch" href="/Weblog/assets/js/3.9c9ae281.js"><link rel="prefetch" href="/Weblog/assets/js/30.e02a9f2a.js"><link rel="prefetch" href="/Weblog/assets/js/31.4d5d63f6.js"><link rel="prefetch" href="/Weblog/assets/js/32.2652c4b5.js"><link rel="prefetch" href="/Weblog/assets/js/33.f81118fb.js"><link rel="prefetch" href="/Weblog/assets/js/34.6539d2a9.js"><link rel="prefetch" href="/Weblog/assets/js/35.479b4b73.js"><link rel="prefetch" href="/Weblog/assets/js/36.24e9784f.js"><link rel="prefetch" href="/Weblog/assets/js/37.13a7e720.js"><link rel="prefetch" href="/Weblog/assets/js/38.57e7625b.js"><link rel="prefetch" href="/Weblog/assets/js/39.40ddc61b.js"><link rel="prefetch" href="/Weblog/assets/js/4.cb1adf5e.js"><link rel="prefetch" href="/Weblog/assets/js/40.4abade23.js"><link rel="prefetch" href="/Weblog/assets/js/41.03a22716.js"><link rel="prefetch" href="/Weblog/assets/js/42.4bf6acac.js"><link rel="prefetch" href="/Weblog/assets/js/43.7d75114c.js"><link rel="prefetch" href="/Weblog/assets/js/44.a74a0979.js"><link rel="prefetch" href="/Weblog/assets/js/45.224f0ae1.js"><link rel="prefetch" href="/Weblog/assets/js/46.716c0ee0.js"><link rel="prefetch" href="/Weblog/assets/js/47.a44c77ff.js"><link rel="prefetch" href="/Weblog/assets/js/48.c92bc6c3.js"><link rel="prefetch" href="/Weblog/assets/js/49.78d85a96.js"><link rel="prefetch" href="/Weblog/assets/js/5.c1152841.js"><link rel="prefetch" href="/Weblog/assets/js/50.65d4cc82.js"><link rel="prefetch" href="/Weblog/assets/js/51.dfe21a00.js"><link rel="prefetch" href="/Weblog/assets/js/52.a55d1d66.js"><link rel="prefetch" href="/Weblog/assets/js/53.24e5ba30.js"><link rel="prefetch" href="/Weblog/assets/js/54.3d44c9e1.js"><link rel="prefetch" href="/Weblog/assets/js/55.5509d3c1.js"><link rel="prefetch" href="/Weblog/assets/js/56.389f0044.js"><link rel="prefetch" href="/Weblog/assets/js/57.a6410cdf.js"><link rel="prefetch" href="/Weblog/assets/js/58.99de433a.js"><link rel="prefetch" href="/Weblog/assets/js/59.f362327e.js"><link rel="prefetch" href="/Weblog/assets/js/6.829d0e7e.js"><link rel="prefetch" href="/Weblog/assets/js/60.d8a731fd.js"><link rel="prefetch" href="/Weblog/assets/js/61.c32405a4.js"><link rel="prefetch" href="/Weblog/assets/js/62.2cf15697.js"><link rel="prefetch" href="/Weblog/assets/js/63.97976992.js"><link rel="prefetch" href="/Weblog/assets/js/64.df2f0acc.js"><link rel="prefetch" href="/Weblog/assets/js/65.0365fc24.js"><link rel="prefetch" href="/Weblog/assets/js/66.89f67105.js"><link rel="prefetch" href="/Weblog/assets/js/67.4d546178.js"><link rel="prefetch" href="/Weblog/assets/js/68.b3742591.js"><link rel="prefetch" href="/Weblog/assets/js/69.e2c032ec.js"><link rel="prefetch" href="/Weblog/assets/js/7.1f4a6057.js"><link rel="prefetch" href="/Weblog/assets/js/70.f262dfb0.js"><link rel="prefetch" href="/Weblog/assets/js/71.24d5a255.js"><link rel="prefetch" href="/Weblog/assets/js/72.c2fad7bd.js"><link rel="prefetch" href="/Weblog/assets/js/73.e3de86c7.js"><link rel="prefetch" href="/Weblog/assets/js/74.af039d36.js"><link rel="prefetch" href="/Weblog/assets/js/75.b5d26a4d.js"><link rel="prefetch" href="/Weblog/assets/js/76.5253b8d4.js"><link rel="prefetch" href="/Weblog/assets/js/77.13049fae.js"><link rel="prefetch" href="/Weblog/assets/js/78.732e7950.js"><link rel="prefetch" href="/Weblog/assets/js/79.91a95405.js"><link rel="prefetch" href="/Weblog/assets/js/8.5b6e1357.js"><link rel="prefetch" href="/Weblog/assets/js/80.60b08cac.js"><link rel="prefetch" href="/Weblog/assets/js/81.09852d19.js"><link rel="prefetch" href="/Weblog/assets/js/82.49b521d3.js"><link rel="prefetch" href="/Weblog/assets/js/83.681a706a.js"><link rel="prefetch" href="/Weblog/assets/js/84.ca93e702.js"><link rel="prefetch" href="/Weblog/assets/js/85.9813d878.js"><link rel="prefetch" href="/Weblog/assets/js/86.632f014f.js"><link rel="prefetch" href="/Weblog/assets/js/87.7737cd73.js"><link rel="prefetch" href="/Weblog/assets/js/88.1ec9c00d.js"><link rel="prefetch" href="/Weblog/assets/js/89.bbeb975f.js"><link rel="prefetch" href="/Weblog/assets/js/9.c685ce8f.js"><link rel="prefetch" href="/Weblog/assets/js/90.eda536dd.js"><link rel="prefetch" href="/Weblog/assets/js/91.391681fc.js"><link rel="prefetch" href="/Weblog/assets/js/92.dca04870.js"><link rel="prefetch" href="/Weblog/assets/js/93.01d44a2a.js"><link rel="prefetch" href="/Weblog/assets/js/94.f941a99a.js"><link rel="prefetch" href="/Weblog/assets/js/95.232bf755.js"><link rel="prefetch" href="/Weblog/assets/js/96.d381c6e0.js"><link rel="prefetch" href="/Weblog/assets/js/97.2a0ba8ba.js"><link rel="prefetch" href="/Weblog/assets/js/98.001e708c.js"><link rel="prefetch" href="/Weblog/assets/js/99.0ff7167d.js">
    <link rel="stylesheet" href="/Weblog/assets/css/styles.bc17a3fe.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/Weblog/" class="home-link router-link-active"><!----><span class="site-name">
      AlexTao 的 博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link router-link-active">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link router-link-active">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>Tool</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/Weblog/tool/" aria-current="page" class="sidebar-link">git</a></li><li><a href="/Weblog/tool/前端开发规范.html" class="active sidebar-link">前端开发规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#总体规范" class="sidebar-link">总体规范</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#总体开发须知" class="sidebar-link">总体开发须知</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#html" class="sidebar-link">html</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#css" class="sidebar-link">css</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#javascript" class="sidebar-link">javascript</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#typescript" class="sidebar-link">Typescript</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#移动端优化" class="sidebar-link">移动端优化</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#react-jsx" class="sidebar-link">React&amp;JSX</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#vue" class="sidebar-link">Vue</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#git-仓库分支名规范" class="sidebar-link">Git 仓库分支名规范</a></li><li class="sidebar-sub-header"><a href="/Weblog/tool/前端开发规范.html#git-commit-建议" class="sidebar-link">Git Commit 建议</a></li></ul></li><li><a href="/Weblog/tool/前端工程规范.html" class="sidebar-link">前端工程规范</a></li><li><a href="/Weblog/tool/前端技术方案模板.html" class="sidebar-link">前端技术设计文档模板</a></li><li><a href="/Weblog/tool/win指令.html" class="sidebar-link">Windows 常用新建文件指令</a></li><li><a href="/Weblog/tool/MAC中设置和查看环境变量.html" class="sidebar-link">MAC中设置和查看环境变量</a></li><li><a href="/Weblog/tool/npm命令.html" class="sidebar-link">npm常用命令及包</a></li><li><a href="/Weblog/tool/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/Weblog/tool/Nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/Weblog/tool/echarts配置.html" class="sidebar-link">echarts 属性设置</a></li><li><a href="/Weblog/tool/错误监控.html" class="sidebar-link">错误监控</a></li><li><a href="/Weblog/tool/SEO.html" class="sidebar-link">SEO</a></li><li><a href="/Weblog/tool/util.html" class="sidebar-link">util</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="前端开发规范">前端开发规范</h1><h2 id="总体规范">总体规范</h2><p>参考：</p><ul><li>Airbnb ES6 规范：https://github.com/airbnb/javascript</li><li>Airbnb React 规范：https://github.com/airbnb/javascript/tree/master/react</li><li>TS 校验lint库: http://gitlab.alibaba-inc.com/dt-npm/tslint</li><li>TypeScript dos and don’t https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html</li><li>react-redux-typescript-guide https://github.com/piotrwitek/react-redux-typescript-guide</li></ul><h2 id="总体开发须知">总体开发须知</h2><ul><li>1、字符串中使用单引号 <code>'</code>，JSX 中使用双引号 <code>&quot;</code></li><li>2、采用两格空格缩进</li><li><strong>3</strong>、方法体控制在一屏内显示 (30行左右)，使用两次的逻辑，进行封装抽离</li><li>4、直接使用 this，不要使用 that/self/me。<s>统一使用self替代外层scope的this</s></li><li>5、代码具有连续性，避免无意义的换行</li><li>6、用 es5-shim 和 es6-shim 里的方法，而不是lodash或jquery的同名方法，如 <code>forEach</code>, <code>bind</code></li><li><strong>7</strong>、回调原则上不允许超过两层，三层必须用promise处理，建议使用 async await</li><li><strong>8</strong>、component命令方式一率用大驼峰，目录用小写加横杠</li><li>9、统一使用unix换行符，即/n</li><li>10、不要使用 getter/setter，使用明确的 method</li><li>11、使用 <code>===</code> 和 <code>!==</code> 替换 <code>==</code> 和 <code>!=</code>，只有在判断 <code>undefined</code> 和 <code>null</code> 时除外，用 <code>undefOrNull == null</code></li><li>12、顶层函数定义使用 <code>function name(param1) {}</code>，不要使用 arrow function</li><li>13、文件头部需要添加作者信息，以便于快速联系，author 可以是一个也可以是多个，格式如下：</li></ul><div class="language- extra-class"><pre class="language-text"><code>/**
 * @file 表格显示组件（简要描述下文件功能和应用场景）
  * @author Alex
 */
</code></pre></div><h2 id="html">html</h2><h3 id="通用约定">通用约定</h3><h3 id="文档申明">文档申明</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
</code></pre></div><h3 id="语言申明">语言申明</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;html lang=&quot;zh-CN&quot;&gt;
</code></pre></div><h3 id="编码申明，标准的-utf-8">编码申明，标准的 UTF-8</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;meta charset=&quot;UTF-8&quot;&gt;
</code></pre></div><h3 id="seo优化（tdk）">seo优化（TDK）</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;title&gt;Style Guide&lt;/title&gt; 
&lt;meta name=&quot;keywords&quot; content=&quot;keywords&quot;&gt; 
&lt;meta name=&quot;description&quot; content=&quot;description&quot;&gt; 
&lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;
</code></pre></div><h3 id="标签及闭合">标签及闭合</h3><ul><li>空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</li><li>原始文本元素：script、style</li><li>RCDATA元素：textarea、title</li><li>外来元素：来自MathML命名空间和SVG命名空间的元素。</li><li>常规元素：其他HTML允许的元素都称为常规元素。</li></ul><p><strong>为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，如下约定：</strong></p><ul><li>所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上</li><li>空元素标签都不加 “/” 字符</li><li>尽量减少标签数量</li></ul><h3 id="html代码大小写">HTML代码大小写</h3><p>HTML标签名、类名、标签属性和大部分属性值统一用小写，HTML文本、CDATA、JavaScript、meta标签某些属性等内容可大小写混合</p><div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;

&lt;!-- 优先使用 IE 最新版本和 Chrome Frame --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;

&lt;!-- HTML文本内容 --&gt;
&lt;h1&gt;I AM WHAT I AM &lt;/h1&gt;

&lt;!-- JavaScript 内容 --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	var demoName = 'demoName';
	...
&lt;/script&gt;
	
&lt;!-- CDATA 内容 --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;&lt;![CDATA[
...
]]&gt;&lt;/script&gt;
</code></pre></div><h3 id="class-与-id">Class 与 ID</h3><ul><li>class 应以功能或内容命名，不以表现形式命名；</li><li>class 与 id 单词字母小写，多个单词组成时，采用中划线 - 分隔；</li><li>使用唯一的 id 作为 Javascript hook, 同时避免创建无样式信息的 class；</li></ul><div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;j-hook&quot; class=&quot;sidebar content-wrapper&quot;&gt;&lt;/div&gt; 
</code></pre></div><h3 id="类型属性">类型属性</h3><p>不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含</p><div class="language- extra-class"><pre class="language-text"><code>不推荐：type可以省略

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot; &gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
</code></pre></div><h3 id="元素属性">元素属性</h3><p>属性的定义，统一使用双引号。</p><p>HTML5 规范中 disabled 、 checked 、 selected 等属性不用设置值。</p><div class="language- extra-class"><pre class="language-text"><code> &lt;span id=&quot;j-hook&quot; class=&quot;text&quot;&gt;Google&lt;/span&gt;
 &lt;input type=&quot;text&quot; disabled&gt;
</code></pre></div><h3 id="标签嵌套">标签嵌套</h3><p><code>a 不允许嵌套 div</code> 这种约束属于语义嵌套约束，与之区别的约束还有严格嵌套约束，比如 <code>a 不允许嵌套 a</code> 。</p><p>严格嵌套约束在所有的浏览器下都不被允许；而语义嵌套约束，浏览器大多会容错处理，生成的文档树可能相互不太</p><p>一样。</p><p><strong>语义嵌套约束</strong></p><ul><li><div class="language- extra-class"><pre class="language-text"><code>&lt;li&gt; 用于 &lt;ul&gt; 或 &lt;ol&gt; 下
</code></pre></div></li><li><div class="language- extra-class"><pre class="language-text"><code>&lt;dd&gt; , &lt;dt&gt; 用于 &lt;dl&gt; 下；
</code></pre></div></li><li><div class="language- extra-class"><pre class="language-text"><code>&lt;thead&gt; , &lt;tbody&gt; , &lt;tfoot&gt; , &lt;tr&gt; , &lt;td&gt; 用于 &lt;table&gt; 下； 
</code></pre></div></li></ul><p><strong>严格嵌套约束</strong></p><ul><li><p>inline-Level 元素，仅可以包含文本或其它 inline-Level 元素;</p></li><li><div class="language- extra-class"><pre class="language-text"><code>a里不可以嵌套交互式元素 a,button,select 等;  
</code></pre></div></li><li><div class="language- extra-class"><pre class="language-text"><code>p里不可以嵌套块级元素 div,h1~h6,p,ui,ol,li,dl,dt,dd,from等
</code></pre></div></li></ul><h3 id="标签语意化">标签语意化</h3><p>语义化的 HTML 结构，有助于机器（搜索引擎）理解，另一方面多人协作时，能迅速了解开发者意图。</p><h3 id="viewport">viewport</h3><ul><li>viewport : 一般指的是浏览器窗口内容区的大小，不包含工具条、选项卡等内容；</li><li>width : 浏览器宽度，输出设备中的页面可见区域宽度；</li><li>device-width : 设备分辨率宽度，输出设备的屏幕可见宽度；</li><li>initial-scale : 初始缩放比例；</li><li>maximum-scale : 最大缩放比例；</li></ul><p>为移动端设备优化，设置可见区域的宽度和初始缩放比例。</p><div class="language- extra-class"><pre class="language-text"><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
</code></pre></div><h3 id="ios-图标">iOS 图标</h3><ul><li><p>apple-touch-icon 图片自动处理成圆角和高光等效果;</p></li><li><p>apple-touch-icon-precomposed 禁止系统自动添加效果，直接显示设计原图;</p></li></ul><div class="language- extra-class"><pre class="language-text"><code>&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; 
&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57- precomposed.png&quot;&gt; 

&lt;!-- iPad，72x72 像素，可以没有，但推荐有 --&gt; 
&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-72x72- precomposed.png&quot; sizes=&quot;72x72&quot;&gt; 

&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; 
&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-114x114- precomposed.png&quot; sizes=&quot;114x114&quot;&gt; 

&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; 
&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-144x144- precomposed.png&quot; sizes=&quot;144x144&quot;&gt;
</code></pre></div><h3 id="favicon">favicon</h3><ul><li>在 Web Server 根目录放置 favicon.ico 文件；</li><li>使用 link 指定 favicon；</li></ul><div class="language- extra-class"><pre class="language-text"><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;path/favicon.ico&quot;&gt;
</code></pre></div><h3 id="head-模板">HEAD 模板</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt; 
&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; 
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt; 
		&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 
		&lt;title&gt;不超过60个字符&lt;/title&gt; 
		&lt;meta name=&quot;description&quot; content=&quot;不超过160个字符&quot;&gt; 
		&lt;meta name=&quot;keywords&quot; content=&quot;k1,k2,关键词组，不超过60个字符&quot;&gt; 
		&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;&gt; 
		&lt;!-- 为移动设备添加 viewport --&gt; 
		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 
		&lt;!-- iOS 图标 --&gt; 
		&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57- precomposed.png&quot;&gt; 
		&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot; /&gt; 
		&lt;link rel=&quot;shortcut icon&quot; href=&quot;path/to/favicon.ico&quot;&gt; 
	&lt;/head&gt;
&lt;/html&gt;
</code></pre></div><h2 id="css">css</h2><h3 id="class-和-id">Class 和 ID</h3><ul><li>使用语义化、通用的命名方式；</li><li>使用连字符 - 作为 ID、Class 名称界定符，不要驼峰命名法和下划线；</li><li>避免选择器嵌套层级过多，尽量少于 3 级，最多不超过 7 级；</li><li>避免选择器和 Class、ID 叠加使用；</li></ul><h3 id="申明块格式">申明块格式</h3><ul><li>选择器分组时，保持独立的选择器占用一行；</li><li>声明块的左括号 { 前添加一个空格；</li><li>声明块的右括号 } 应单独成行；</li><li>声明语句中的 : 后应添加一个空格；</li><li>声明语句应以分号 ; 结尾；</li><li>一般以逗号分隔的属性值，每个逗号后应添加一个空格；</li><li>rgb() 、 rgba() 、 hsl() 、 hsla() 或 rect() 括号内的值，逗号分隔，但逗号后不添加一个空格；</li><li>对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如， .5 代替 0.5 ； -.5px 代替 -0.5px ）；</li><li>十六进制值应该全部小写和尽量简写，例如， #fff 代替 #ffffff ；</li><li>避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;</li><li>代码缩进，2 或 4个空格，推荐2个空格</li></ul><h3 id="书写顺序">书写顺序</h3><ul><li>Positioning</li><li>Box model</li><li>Typographic</li><li>Visual</li></ul><p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因 此排在首位。盒模型决定了组件的尺寸和位置，因此排在第二位。 其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。</p><div class="language- extra-class"><pre class="language-text"><code>.declaration-order { 

	/* Positioning */ 
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	z-index: 100;
	
	/* Box model */
  display: block;
  box-sizing: border-box;
  width: 100px;
  height: 100px;
  padding: 10px;
  border: 1px solid #e5e5e5;
  border-radius: 3px;
  margin: 10px;
  float: right;
  overflow: hidden;
  
  /* Typographic */ 
  font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; 
  line-height: 1.5;
  text-align: center; 
  
  /* Visual */ 
  background-color: #f5f5f5; 
  color: #fff;
  opacity: .8; 
  
  /* Other */
  cursor: pointer;
}
</code></pre></div><h3 id="链接的样式顺序：">链接的样式顺序：</h3><div class="language- extra-class"><pre class="language-text"><code>a:link -&gt; a:visited -&gt; a:hover -&gt; a:active（LoVeHAte）
</code></pre></div><h3 id="浏览器私有前缀写法">浏览器私有前缀写法</h3><p>使用 <strong>Autoprefixer</strong> 自动添加浏览器厂商前缀</p><div class="language- extra-class"><pre class="language-text"><code>.box {
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
</code></pre></div><h3 id="性能优化">性能优化</h3><h4 id="慎重选择高消耗的样式-高消耗属性在绘制前需要浏览器进行大量计算">慎重选择高消耗的样式,高消耗属性在绘制前需要浏览器进行大量计算</h4><ul><li>box-shadows</li><li>border-radius</li><li>transparency</li><li>transforms</li><li>CSS filters（性能杀手）</li></ul><h4 id="避免过分重排-发生重排的时候，浏览器需要重新计算布局位置与大小">避免过分重排,发生重排的时候，浏览器需要重新计算布局位置与大小</h4><p>常见的重排元素:</p><ul><li>width</li><li>height</li><li>padding</li><li>margin</li><li>display</li><li>border-width</li><li>position</li><li>top</li><li>left</li><li>right</li><li>bottom</li><li>font-size</li><li>float</li><li>text-align</li><li>overflow-y</li><li>font-weight</li><li>overflow</li><li>font-family</li><li>line-height</li><li>vertical-align</li><li>clear</li><li>white-space</li><li>min-height</li></ul><h4 id="正确使用-display-的属性-display-属性会影响页面的渲染">正确使用 Display 的属性,Display 属性会影响页面的渲染</h4><ul><li>display: inline后不应该再使用 width、height、margin、padding 以及 float；</li><li>display: inline-block 后不应该再使用 float；</li><li>display: block 后不应该再使用 vertical-align；</li><li>display: table-* 后不应该再使用 margin 或者 float；</li></ul><h4 id="不滥用-float">不滥用 Float</h4><p>Float在渲染时计算量比较大，尽量减少使用。</p><h4 id="动画性能优化">动画性能优化</h4><p>动画的实现原理，是利用了人眼的“视觉暂留”现象，在短时间内连续播放数幅静止的画面，使肉眼因视觉残象产生错</p><p>觉，而误以为画面在“动”。</p><p><strong>动画的基本概念：</strong></p><ul><li>帧：在动画过程中，每一幅静止画面即为一“帧”;</li><li>帧率：即每秒钟播放的静止画面的数量，单位是fps(Frame per second);</li><li>帧时长：即每一幅静止画面的停留时间，单位一般是ms(毫秒);</li><li>跳帧(掉帧/丢帧)：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续数帧被挤压而丢失的现</li><li>象。</li></ul><p>一般浏览器的渲染刷新频率是 60 fps，所以在网页当中，帧率如果达到 50-60 fps 的动画将会相当流畅，让人感</p><p>到舒适。</p><ul><li>如果使用基于 javaScript 的动画，尽量使用 requestAnimationFrame. 避免使用 setTimeout, setInterval.</li><li>避免通过类似 jQuery animate()-style 改变每帧的样式，使用 CSS 声明动画会得到更好的浏览器优化。</li><li>使用 translate 取代 absolute 定位就会得到更好的 fps，动画会更顺滑。</li></ul><h4 id="利用硬件能力，如通过-3d-变形开启-gpu-加速">利用硬件能力，如通过 3D 变形开启 GPU 加速</h4><p>一般在 Chrome 中，3D或透视变换（perspective transform）CSS属性和对 opacity 进行 CSS 动画会创建</p><p>新的图层，在硬件加速渲染通道的优化下，GPU 完成 3D 变形等操作后，将图层进行复合操作（Compesite</p><p>Layers），从而避免触发浏览器大面积重绘和重排。</p><p><strong>注：3D 变形会消耗更多的内存和功耗。</strong></p><h2 id="javascript">javascript</h2><h3 id="类型">类型</h3><ul><li><p>原始类型: 存取原始类型直接作用于值本身</p><ul><li>布尔类型</li><li>Null 类型</li><li>Undefined 类型</li><li>数字类型</li><li>BigInt 类型</li><li>字符串类型</li><li>符号类型 Symbol</li></ul><div class="language- extra-class"><pre class="language-text"><code>const foo = 1
let bar = foo

bar = 9

console.log(foo, bar) // 1, 9
</code></pre></div></li><li><p>复杂类型: 访问复杂类型作用于值的引用</p><ul><li>object</li><li>array</li><li>function</li></ul><div class="language- extra-class"><pre class="language-text"><code>const foo = [1, 2, 3]
const bar = foo

bar[0] = 9

console.log(foo[0], bar[0]) // 9, 9
</code></pre></div></li></ul><h3 id="引用">引用</h3><ul><li>请记得 <code>const</code> 和 <code>let</code> 都是块级作用域，<code>var</code> 是函数级作用域</li></ul><div class="language- extra-class"><pre class="language-text"><code>// const and let only exist in the blocks they are defined in.
{
  let a = 1
  const b = 1
}
console.log(a) // ReferenceError
console.log(b) // ReferenceError
</code></pre></div><ul><li>对所有引用都使用 <code>const</code>，不要使用 <code>var</code>，eslint: <a href="https://eslint.org/docs/rules/prefer-const.html" target="_blank" rel="noopener noreferrer">prefer-const<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://eslint.org/docs/rules/no-const-assign.html" target="_blank" rel="noopener noreferrer">no-const-assign<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：这样做可以确保你无法重新分配引用，以避免出现错误和难以理解的代码</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
var a = 1
var b = 2

// good
const a = 1
const b = 2
</code></pre></div><ul><li>如果引用是可变动的，使用 <code>let</code> 代替 <code>var</code>，eslint: <a href="https://eslint.org/docs/rules/no-var.html" target="_blank" rel="noopener noreferrer">no-var<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：<code>let</code> 是块级作用域的，而不像 <code>var</code> 属于函数级作用域</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
var count = 1
if (count &lt; 10) {
  count += 1
}

// good
let count = 1
if (count &lt; 10) {
  count += 1
}
</code></pre></div><h3 id="对象">对象</h3><ul><li><p>请使用字面量值创建对象，eslint: <a href="https://eslint.org/docs/rules/no-new-object.html" target="_blank" rel="noopener noreferrer">no-new-object<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>// bad
const a = new Object{}

// good
const a = {}
</code></pre></div></li><li><p>别使用保留字作为对象的键值，这样在 IE8 下不会运行</p><div class="language- extra-class"><pre class="language-text"><code>// bad
const a = {
  default: {},  // default 是保留字
  common: {}
}

// good
const a = {
  defaults: {},
  common: {}
}
</code></pre></div></li><li><p>当使用动态属性名创建对象时，请使用对象计算属性名来进行创建</p></li></ul><blockquote><p>原因：因为这样做就可以让你在一个地方定义所有的对象属性</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>function getKey(k) {
  return `a key named ${k}`
}

// bad
const obj = {
  id: 5,
  name: 'San Francisco'
};
obj[getKey('enabled')] = true

// good
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true
};
</code></pre></div><ul><li><p>请使用对象方法的简写方式，eslint: <a href="https://eslint.org/docs/rules/object-shorthand.html" target="_blank" rel="noopener noreferrer">object-shorthand<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>// bad
const item = {
  value: 1,

  addValue: function (val) {
    return item.value + val
  }
}

// good
const item = {
  value: 1,

  addValue (val) {
    return item.value + val
  }
}
</code></pre></div></li><li><p>请使用对象属性值的简写方式，eslint: <a href="https://eslint.org/docs/rules/object-shorthand.html" target="_blank" rel="noopener noreferrer">object-shorthand<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><blockquote><p>原因：这样更简短且描述更清楚</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>const job = 'FrontEnd'

// bad
const item = {
  job: job
}

// good
const item = {
  job
}
</code></pre></div></li><li><p>将简写的对象属性分组后统一放到对象声明的开头</p></li></ul><blockquote><p>原因：这样更容易区分哪些属性用了简写的方式</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>const job = 'FrontEnd'
const department = 'JDC'

// bad
const item = {
  sex: 'male',
  job,
  age: 25,
  department
}

// good
const item = {
  job,
  department,
  sex: 'male',
  age: 25
}
</code></pre></div><ul><li>只对非法标识符的属性使用引号，eslint: <a href="https://eslint.org/docs/rules/quote-props.html" target="_blank" rel="noopener noreferrer">quote-props<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：因为通常来说我们认为这样主观上会更容易阅读，这样会带来代码高亮上的提升，同时也更容易被主流 JS 引擎优化</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
const bad = {
  'foo': 3,
  'bar': 4,
  'data-blah': 5
}

// good
const good = {
  foo: 3,
  bar: 4,
  'data-blah': 5
}
</code></pre></div><ul><li><p>不要直接使用</p><div class="language- extra-class"><pre class="language-text"><code>Object.prototype
</code></pre></div><p>的方法, 例如</p><div class="language- extra-class"><pre class="language-text"><code>hasOwnProperty
</code></pre></div><p>,</p><div class="language- extra-class"><pre class="language-text"><code>propertyIsEnumerable
</code></pre></div><p>和</p><div class="language- extra-class"><pre class="language-text"><code>isPrototypeOf
</code></pre></div><p>方法，eslint:</p><p>no-prototype-builtins</p><blockquote><p>原因：这些方法可能会被对象自身的同名属性覆盖 - 比如 <code>{ hasOwnProperty: false }</code> 或者对象可能是一个 <code>null</code> 对象(<code>Object.create(null)</code>)</p></blockquote></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
console.log(object.hasOwnProperty(key))

// good
console.log(Object.prototype.hasOwnProperty.call(object, key))

// best
const has = Object.prototype.hasOwnProperty // cache the lookup once, in module scope.
console.log(has.call(object, key))
/* or */
import has from 'has' // https://www.npmjs.com/package/has
console.log(has(object, key))
</code></pre></div><ul><li>优先使用对象展开运算符 <code>...</code> 来做对象浅拷贝而不是使用 <code>Object.assign</code>，使用对象剩余操作符来获得一个包含确定的剩余属性的新对象</li></ul><div class="language- extra-class"><pre class="language-text"><code>// very bad
const original = { a: 1, b: 2 }
const copy = Object.assign(original, { c: 3 }) // this mutates `original` ಠ_ಠ
delete copy.a // so does this

// bad
const original = { a: 1, b: 2 }
const copy = Object.assign({}, original, { c: 3 }) // copy =&gt; { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 }
const copy = { ...original, c: 3 } // copy =&gt; { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy // noA =&gt; { b: 2, c: 3 }
</code></pre></div><h3 id="数组">数组</h3><ul><li><p>请使用字面量值创建数组，eslint: <a href="https://eslint.org/docs/rules/no-array-constructor.html" target="_blank" rel="noopener noreferrer">no-array-constructor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>// bad
const items = new Array()

// good
const items = []
</code></pre></div></li><li><p>向数组中添加元素时，请使用 <code>push</code> 方法</p><div class="language- extra-class"><pre class="language-text"><code>const items = []

// bad
items[items.length] = 'test'

// good
items.push('test')
</code></pre></div></li><li><p>使用展开运算符 <code>...</code> 复制数组</p><div class="language- extra-class"><pre class="language-text"><code>// bad
const items = []
const itemsCopy = []
const len = items.length
let i

// bad
for (i = 0; i &lt; len; i++) {
  itemsCopy[i] = items[i]
}

// good
itemsCopy = [...items]
</code></pre></div></li><li><p>把一个可迭代的对象转换为数组时，使用展开运算符 <code>...</code> 而不是 <code>Array.from</code></p></li></ul><div class="language- extra-class"><pre class="language-text"><code>const foo = document.querySelectorAll('.foo')

// good
const nodes = Array.from(foo)

// best
const nodes = [...foo]
</code></pre></div><ul><li>使用 <code>Array.from</code> 来将一个类数组对象转换为数组</li></ul><div class="language- extra-class"><pre class="language-text"><code>const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 }

// bad
const arr = Array.prototype.slice.call(arrLike)

// good
const arr = Array.from(arrLike)
</code></pre></div><ul><li>遍历迭代器进行映射时使用 <code>Array.from</code> 代替扩展运算符 <code>...</code>, 因为这可以避免创建中间数组</li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
const baz = [...foo].map(bar)

// good
const baz = Array.from(foo, bar)
</code></pre></div><ul><li><p>使用数组的 <code>map</code> 等方法时，请使用 <code>return</code> 声明，如果是单一声明语句的情况，可省略 <code>return</code></p><div class="language- extra-class"><pre class="language-text"><code>// good
[1, 2, 3].map(x =&gt; {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map(x =&gt; x + 1)

// bad
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; {
  const flatten = memo.concat(item)
  flat[index] = flatten
})

// good
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; {
  const flatten = memo.concat(item)
  flat[index] = flatten
  return flatten
})

// bad
inbox.filter((msg) =&gt; {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  } else {
    return false
  }
})

// good
inbox.filter((msg) =&gt; {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  }

  return false
})
</code></pre></div></li><li><p>如果一个数组有多行则要在数组的开括号后和闭括号前使用新行</p></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
const arr = [
  [0, 1], [2, 3], [4, 5]
]

const objectInArray = [{
  id: 1
}, {
  id: 2
}]

const numberInArray = [
  1, 2
]

// good
const arr = [[0, 1], [2, 3], [4, 5]]

const objectInArray = [
  {
    id: 1
  },
  {
    id: 2
  }
]

const numberInArray = [
  1,
  2
]
</code></pre></div><h3 id="解构赋值">解构赋值</h3><ul><li>当需要使用对象的多个属性时，请使用解构赋值，eslint: <a href="https://eslint.org/docs/rules/prefer-destructuring" target="_blank" rel="noopener noreferrer">prefer-destructuring<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>愿意：解构可以避免创建属性的临时引用</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
function getFullName (user) {
  const firstName = user.firstName
  const lastName = user.lastName

  return `${firstName} ${lastName}`
}

// good
function getFullName (user) {
  const { firstName, lastName } = user

  return `${firstName} ${lastName}`
}

// better
function getFullName ({ firstName, lastName }) {
  return `${firstName} ${lastName}`
}
</code></pre></div><ul><li><p>当需要使用数组的多个值时，请同样使用解构赋值，eslint: <a href="https://eslint.org/docs/rules/prefer-destructuring" target="_blank" rel="noopener noreferrer">prefer-destructuring<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3, 4]

// bad
const first = arr[0]
const second = arr[1]

// good
const [first, second] = arr
</code></pre></div></li><li><p>函数需要回传多个值时，请使用对象的解构，而不是数组的解构</p></li></ul><blockquote><p>原因：可以非破坏性地随时增加或者改变属性顺序</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
function doSomething () {
  return [top, right, bottom, left]
}

// 如果是数组解构，那么在调用时就需要考虑数据的顺序
const [top, xx, xxx, left] = doSomething()

// good
function doSomething () {
  return { top, right, bottom, left }
}

// 此时不需要考虑数据的顺序
const { top, left } = doSomething()
</code></pre></div><h3 id="字符串">字符串</h3><ul><li><p>字符串统一使用单引号的形式 <code>''</code>，eslint: <a href="https://eslint.org/docs/rules/quotes.html" target="_blank" rel="noopener noreferrer">quotes<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>// bad
const department = &quot;JDC&quot;

// good
const department = 'JDC'
</code></pre></div></li><li><p>字符串太长的时候，请不要使用字符串连接符换行 <code>\</code>，而是使用 <code>+</code></p><div class="language- extra-class"><pre class="language-text"><code>const str = '凹凸实验室 凹凸实验室 凹凸实验室' +
  '凹凸实验室 凹凸实验室 凹凸实验室' +
  '凹凸实验室 凹凸实验室'
</code></pre></div></li><li><p>程序化生成字符串时，请使用模板字符串，eslint: <a href="http://eslint.org/docs/rules/prefer-template.html" target="_blank" rel="noopener noreferrer">prefer-template<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a href="https://eslint.org/docs/rules/template-curly-spacing" target="_blank" rel="noopener noreferrer">template-curly-spacing<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>const test = 'test'

// bad
const str = ['a', 'b', test].join()

// bad
const str = 'a' + 'b' + test

// good
const str = `ab${test}`
</code></pre></div></li><li><p>不要对字符串使用eval()，会导致太多漏洞， eslint: <a href="https://eslint.org/docs/rules/no-eval" target="_blank" rel="noopener noreferrer">no-eval<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p>不要在字符串中使用不必要的转义字符， eslint: <a href="https://eslint.org/docs/rules/no-useless-escape" target="_blank" rel="noopener noreferrer">no-useless-escape<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
const foo = '\'this\' \i\s \&quot;quoted\&quot;'

// good
const foo = '\'this\' is &quot;quoted&quot;'
const foo = `my name is '${name}'`
</code></pre></div><h3 id="函数">函数</h3><ul><li>不要使用Function构造函数创建函数， eslint: <a href="https://eslint.org/docs/rules/no-new-func" target="_blank" rel="noopener noreferrer">no-new-func<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：此方式创建函数和对字符串使用 <code>eval()</code> 一样会产生漏洞</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
const add = new Function('a', 'b', 'return a + b')

// still bad
const subtract = Function('a', 'b', 'return a - b')
</code></pre></div><ul><li>在函数签名中使用空格，eslint: <a href="https://eslint.org/docs/rules/space-before-function-paren" target="_blank" rel="noopener noreferrer">space-before-function-paren<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a href="https://eslint.org/docs/rules/space-before-blocks" target="_blank" rel="noopener noreferrer">space-before-blocks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="language- extra-class"><pre class="language-text"><code>const f = function(){}
const g = function (){}
const h = function() {}

// good
const x = function b () {}
const y = function a () {}
</code></pre></div><ul><li>使用具名函数表达式而非函数声明，eslint: <a href="http://eslint.org/docs/rules/func-style" target="_blank" rel="noopener noreferrer">func-style<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：这样做会导致函数声明被提升，这意味着很容易在文件中定义此函数之前引用它，不利于可读性和可维护性。如果你发现函数定义既庞大又复杂以至于不能理解文件的其他部分，或许你应该将它拆分成模块！别忘记要显式命名表达式，而不用管名字是否是从包含的变量（通常出现在现代浏览器中或者使用 Babel 编译器的时候）中推断的。这样会消除错误调用堆栈中的任何假设。 (讨论)</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
function foo () {
  // ...
}

// bad
const foo = function () {
  // ...
}

// good
// lexical name distinguished from the variable-referenced invocation(s)
const short = function longUniqueMoreDescriptiveLexicalFoo () {
  // ...
}
</code></pre></div><ul><li>用圆括号包裹自执行匿名函数，eslint：<a href="http://eslint.org/docs/rules/wrap-iife.html" target="_blank" rel="noopener noreferrer">wrap-iife<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：一个立即执行匿名函数表达式是一个单一的单元，将其及其调用括号包装在括号中，能够清楚地表达这一点。注意，在到处都是模块的世界中几乎不需要 IIFE。</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// immediately-invoked function expression (IIFE)
(function () {
  console.log('Welcome to the Internet. Please follow me.')
}())
</code></pre></div><ul><li><p>不要在非函数代码块（<code>if</code> , <code>while</code> 等）中声明函数，eslint：<a href="http://eslint.org/docs/rules/no-loop-func.html" target="_blank" rel="noopener noreferrer">no-loop-func<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>// bad
if (isUse) {
  function test () {
    // do something
  }
}

// good
let test
if (isUse) {
  test = () =&gt; {
    // do something
  }
}
</code></pre></div></li><li><p>不要将参数命名为 <code>arguments</code>，会导致该参数的优先级高于每个函数作用域内原先存在的 <code>arguments</code> 对象</p></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
function foo (name, options, arguments) {
  // ...
}

// good
function foo (name, options, args) {
  // ...
}
</code></pre></div><ul><li><p>不要使用 <code>arguments</code>，使用 剩余运算符 <code>...</code></p><blockquote><p><code>arguments</code> 只是一个类数组，而 <code>...</code> 是一个真正的数组</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
function test () {
  const args = Array.prototype.slice.call(arguments)
  return args.join('')
}

// good
function test (...args) {
  return args.join('')
}
</code></pre></div></li><li><p>使用参数默认值语法而不是修改函数参数</p></li></ul><div class="language- extra-class"><pre class="language-text"><code>// really bad
function handleThings (opts) {
  // No! We shouldn't mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.
  opts = opts || {}
  // ...
}

// still bad
function handleThings (opts) {
  if (opts === void 0) {
    opts = {}
  }
  // ...
}

// good
function handleThings (opts = { }) {
  // ...
}
</code></pre></div><ul><li>避免参数默认值的副作用</li></ul><div class="language- extra-class"><pre class="language-text"><code>let b = 1
// bad
function count (a = b++) {
  console.log(a)
}
count()  // 1
count()  // 2
count(3) // 3
count()  // 3
</code></pre></div><ul><li>将参数默认值放在最后</li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
function handleThings (opts = {}, name) {
  // ...
}

// good
function handleThings (name, opts = {}) {
  // ...
}
</code></pre></div><ul><li>不要更改参数，eslint: <a href="https://eslint.org/docs/rules/no-param-reassign.html" target="_blank" rel="noopener noreferrer">no-param-reassign<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：操作作为参数传入的对象可能在原始调用中造成意想不到的变量副作用</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
function f1 (obj) {
  obj.key = 1
}

// good
function f2 (obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1
}
</code></pre></div><ul><li>不要给参数重新赋值，eslint: <a href="https://eslint.org/docs/rules/no-param-reassign.html" target="_blank" rel="noopener noreferrer">no-param-reassign<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：参数重新赋值可能会导致无法预期的行为，尤其是当操作 <code>arguments</code> 对象时，也可能导致优化问题，尤其是在 V8 引擎中</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
function f1 (a) {
  a = 1
}

function f2 (a) {
  if (!a) { a = 1 }
}

// good
function f3 (a) {
  const b = a || 1
}

function f4 (a = 1) {
}
</code></pre></div><ul><li>调用可变参数函数时建议使用展开运算符 <code>....</code>， eslint: <a href="http://eslint.org/docs/rules/prefer-spread" target="_blank" rel="noopener noreferrer">prefer-spread<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：显然你无需使用上下文，很难结合 <code>new</code> 和 <code>apply</code></p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
const x = [1, 2, 3, 4, 5]
console.log.apply(console, x)

// good
const x = [1, 2, 3, 4, 5]
console.log(...x)

// bad
new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]))

// good
new Date(...[2016, 8, 5])
</code></pre></div><h3 id="箭头函数">箭头函数</h3><ul><li>当你必须使用函数表达式（传递匿名函数）时，使用箭头函数标记. eslint: <a href="http://eslint.org/docs/rules/prefer-arrow-callback.html" target="_blank" rel="noopener noreferrer">prefer-arrow-callback<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://eslint.org/docs/rules/arrow-spacing.html" target="_blank" rel="noopener noreferrer">arrow-spacing<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：它将创建在 <code>this</code> 上下文中执行的函数版本，通常是您想要的，并且语法更简洁</p></blockquote><blockquote><p>如果您有一个相当复杂的函数，则可以将该逻辑移到其自己的命名函数表达式中</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
[1, 2, 3].map(function (x) {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map((x) =&gt; {
  const y = x + 1
  return x * y
})
</code></pre></div><ul><li>如果函数体只包含一条没有副作用的返回表达式的语句，可以省略花括号并使用隐式的 <code>return</code>， 否则保留花括号并使用 <code>return</code> 语句，eslint: <a href="https://eslint.org/docs/rules/arrow-parens.html" target="_blank" rel="noopener noreferrer">arrow-parens<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://eslint.org/docs/rules/arrow-body-style.html" target="_blank" rel="noopener noreferrer">arrow-body-style<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
[1, 2, 3].map(number =&gt; {
  const nextNumber = number + 1
  `A string containing the ${nextNumber}.`
})

// good
[1, 2, 3].map(number =&gt; `A string containing the ${number}.`)

// good
[1, 2, 3].map((number) =&gt; {
  const nextNumber = number + 1
  return `A string containing the ${nextNumber}.`
})

// good
[1, 2, 3].map((number, index) =&gt; ({
  index: number
}))

// No implicit return with side effects
function foo(callback) {
  const val = callback()
  if (val === true) {
    // Do something if callback returns true
  }
}

let bool = false

// bad
foo(() =&gt; bool = true)

// good
foo(() =&gt; {
  bool = true
})
</code></pre></div><ul><li>一旦表达式跨多行，使用圆括号包裹以便更好阅读</li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
['get', 'post', 'put'].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
)

// good
['get', 'post', 'put'].map(httpMethod =&gt; (
  Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
))
</code></pre></div><ul><li>函数如果只接收一个参数并且没使用用花括号，则省略圆括号，否则为了清晰明确则使用圆括号包裹参数，注意：总是使用圆括号也是可以接受的，eslint 中的 <a href="https://eslint.org/docs/rules/arrow-parens#always" target="_blank" rel="noopener noreferrer">“always” 选项<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，eslint: <a href="http://eslint.org/docs/rules/arrow-parens.html" target="_blank" rel="noopener noreferrer">arrow-parens<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
[1, 2, 3].map((x) =&gt; x * x)

// good
[1, 2, 3].map(x =&gt; x * x)

// good
[1, 2, 3].map(number =&gt; (
  `A long string with the ${number}. It’s so long that we’ve broken it ` +
  'over multiple lines!'
))

// bad
[1, 2, 3].map(x =&gt; {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map((x) =&gt; {
  const y = x + 1
  return x * y
})
</code></pre></div><h3 id="类-构造函数">类&amp;构造函数</h3><ul><li><p>使用 <code>class</code>，避免直接操作 <code>prototype</code></p><div class="language- extra-class"><pre class="language-text"><code>// bad
function Queue (contents = []) {
  this._queue = [..contents]
}
Queue.prototype.pop = function () {
  const value = this._queue[0]
  this._queue.splice(0, 1)
  return value
}

// good
class Queue {
  constructor (contents = []) {
    this._queue = [...contents]
  }

  pop () {
    const value = this._queue[0]
    this._queue.splice(0, 1)
    return value
  }
}
</code></pre></div></li><li><p>使用 <code>extends</code> 来实现继承</p></li></ul><blockquote><p>原因：这是一个不会破坏 <code>instanceof</code> 的内建实现原型式继承的方式</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
const inherits = require('inherits')
function PeekableQueue(contents) {
  Queue.apply(this, contents)
}
inherits(PeekableQueue, Queue)
PeekableQueue.prototype.peek = function () {
  return this.queue[0]
}

// good
class PeekableQueue extends Queue {
  peek () {
    return this.queue[0]
  }
}
</code></pre></div><ul><li>如果未声明构造函数，则类会有一个默认的构造函数，没必要用空的构造函数或者将其委托给父类，eslint: <a href="http://eslint.org/docs/rules/no-useless-constructor" target="_blank" rel="noopener noreferrer">no-useless-constructor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
class Jedi {
  constructor () {}

  getName() {
    return this.name
  }
}

// bad
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
  }
}

// good
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
    this.name = 'Rey'
  }
}
</code></pre></div><ul><li>避免类成员重复，eslint: <a href="https://eslint.org/docs/rules/no-dupe-class-members" target="_blank" rel="noopener noreferrer">no-dupe-class-members<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：重复的类成员声明会默认使用最后声明的，通常会导致 bug</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
class Foo {
  bar () { return 1 }
  bar () { return 2 }
}

// good
class Foo {
  bar () { return 1 }
}

// good
class Foo {
  bar () { return 2 }
}
</code></pre></div><h3 id="模块">模块</h3><ul><li>使用标准的 ES6 模块语法 <code>import</code> 和 <code>export</code></li></ul><blockquote><p>原因：模块是未来，让我们现在开始使用未来的特性</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
const util = require('./util')
module.exports = util

// good
import Util from './util'
export default Util

// better
import { Util } from './util'
export default Util
</code></pre></div><ul><li><p>不要使用 <code>import</code> 的通配符 <code>*</code>，这样可以确保你只有一个默认的 export</p><div class="language- extra-class"><pre class="language-text"><code>// bad
import * as Util from './util'

// good
import Util from './util'
</code></pre></div></li><li><p>同个文件每个模块只允许 <code>import</code> 一次，有多个 <code>import</code> 请书写在一起，eslint: <a href="https://eslint.org/docs/rules/no-duplicate-imports" target="_blank" rel="noopener noreferrer">no-duplicate-imports<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul><blockquote><p>原因：这样可以让代码更易于维护</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
import foo from 'foo'
// … some other imports … //
import { named1, named2 } from 'foo'

// good
import foo, { named1, named2 } from 'foo'

// good
import foo, {
  named1,
  named2
} from 'foo'
</code></pre></div><ul><li>将所有 <code>import</code> 语句放在文件最前方，eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/first.md" target="_blank" rel="noopener noreferrer">import/imports-first<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
import foo from 'foo'
foo.init()

import bar from 'bar'

// good
import foo from 'foo'
import bar from 'bar'

foo.init()
</code></pre></div><ul><li>多行导入应该像多行数组和对象文字一样缩进</li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
import { longNameA, longNameB, longNameC, longNameD, longNameE } from 'path'

// good
import {
  longNameA,
  longNameB,
  longNameC,
  longNameD,
  longNameE
} from 'path'
</code></pre></div><ul><li>在模块 <code>import</code> 声明中禁止使用 <code>Webpack</code> 的 <code>loader</code> 语法，eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md" target="_blank" rel="noopener noreferrer">import/no-webpack-loader-syntax<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="language- extra-class"><pre class="language-text"><code>// bad
import fooSass from 'css!sass!foo.scss'
import barCss from 'style!css!bar.css'

// good
import fooSass from 'foo.scss'
import barCss from 'bar.css'
</code></pre></div><h3 id="迭代器">迭代器</h3><ul><li>不要使用 <code>iterators</code>，建议使用 JS 更高优先级的函数代替 for-in 或 for-of 循环，除非迫不得已，eslint: <a href="https://eslint.org/docs/rules/no-iterator.html" target="_blank" rel="noopener noreferrer">no-iterator<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a href="https://eslint.org/docs/rules/no-restricted-syntax" target="_blank" rel="noopener noreferrer">no-restricted-syntax<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote></blockquote><div class="language- extra-class"><pre class="language-text"><code>const numbers = [1, 2, 3, 4, 5]

// bad
let sum = 0
for (let num of numbers) {
  sum += num
}

// good
let sum = 0
numbers.forEach(num =&gt; sum += num)

// better
const sum = numbers.reduce((total, num) =&gt; total + num, 0)
</code></pre></div><h3 id="生成器">生成器</h3><ul><li>现阶段请不要使用生成器 <code>generator</code></li></ul><blockquote><p>原因：因为不能很好地翻译成 ES5 代码</p></blockquote><h3 id="对象属性">对象属性</h3><ul><li><p>使用 <code>.</code> 来访问对象属性</p><div class="language- extra-class"><pre class="language-text"><code>const joke = {
  name: 'haha',
  age: 28
}

// bad
const name = joke['name']

// good
const name = joke.name
</code></pre></div></li><li><p>当访问的属性是变量时使用 <code>[]</code></p></li></ul><div class="language- extra-class"><pre class="language-text"><code>const luke = {
  jedi: true,
  age: 28,
}

function getProp (prop) {
  return luke[prop]
}

const isJedi = getProp('jedi')
</code></pre></div><h3 id="变量声明">变量声明</h3><ul><li><p>声明变量时，请使用 <code>const</code>、<code>let</code> 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 <code>const</code> 来声明变量，我们需要避免全局命名空间的污染。eslint: <a href="http://eslint.org/docs/rules/no-undef" target="_blank" rel="noopener noreferrer">no-undef<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a href="http://eslint.org/docs/rules/prefer-const" target="_blank" rel="noopener noreferrer">prefer-const<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language- extra-class"><pre class="language-text"><code>// bad
demo = new Demo()

// good
const demo = new Demo()
</code></pre></div></li><li><p>将所有的 <code>const</code> 和 <code>let</code> 分组</p><div class="language- extra-class"><pre class="language-text"><code>// bad
let a
const b
let c
const d
let e

// good
const b
const d
let a
let c
let e
</code></pre></div></li><li><p>变量不要进行链式赋值</p></li></ul><blockquote><p>原因：变量链式赋值会创建隐藏的全局变量</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
(function example() {
  // JavaScript interprets this as
  // let a = ( b = ( c = 1 ) );
  // The let keyword only applies to variable a; variables b and c become
  // global variables.
  let a = b = c = 1
}())

console.log(a) // throws ReferenceError
console.log(b) // 1
console.log(c) // 1

// good
(function example() {
  let a = 1
  let b = a
  let c = a
}())

console.log(a) // throws ReferenceError
console.log(b) // throws ReferenceError
console.log(c) // throws ReferenceError

// the same applies for `const`
</code></pre></div><ul><li>不允许出现未被使用的变量，eslint: <a href="https://eslint.org/docs/rules/no-unused-vars" target="_blank" rel="noopener noreferrer">no-unused-vars<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><blockquote><p>原因：声明但未被使用的变量通常是不完全重构犯下的错误.这种变量在代码里浪费空间并会给读者造成困扰</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad

var some_unused_var = 42

// Write-only variables are not considered as used.
var y = 10
y = 5

// A read for a modification of itself is not considered as used.
var z = 0
z = z + 1

// Unused function arguments.
function getX (x, y) {
  return x
}

// good

function getXPlusY (x, y) {
  return x + y
}

const x = 1
const y = a + 2

alert(getXPlusY(x, y))

// 'type' is ignored even if unused because it has a rest property sibling.
// This is a form of extracting an object that omits the specified keys.
const { type, ...coords } = data
// 'coords' is now the 'data' object without its 'type' property.
</code></pre></div><h3 id="hoisting">Hoisting</h3><ul><li><p><code>var</code> 存在变量提升的情况，即 <code>var</code> 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 <code>const</code> 和 <code>let</code> 并不存在这种情况，他们被赋予了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener noreferrer">Temporal Dead Zones, TDZ<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>， 了解 <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15" target="_blank" rel="noopener noreferrer">typeof 不再安全<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>很重要</p><div class="language- extra-class"><pre class="language-text"><code>function example () {
  console.log(notDefined)   // =&gt; throws a ReferenceError
}

function example () {
  console.log(declareButNotAssigned)  // =&gt; undefined
  var declaredButNotAssigned = true
}

function example () {
  let declaredButNotAssigned
  console.log(declaredButNotAssigned)   // =&gt; undefined
  declaredButNotAssigned = true
}

function example () {
  console.log(declaredButNotAssigned)   // =&gt; throws a ReferenceError
  console.log(typeof declaredButNotAssigned)  // =&gt; throws a ReferenceError
  const declaredButNotAssigned = true
}
</code></pre></div></li><li><p>匿名函数的变量名会提升，但函数内容不会</p><div class="language- extra-class"><pre class="language-text"><code>function example () {
  console.log(anonymous)  // =&gt; undefined

  anonymous()

  var anonymous = function () {
    console.log('test')
  }
}
</code></pre></div></li><li><p>命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会</p><div class="language- extra-class"><pre class="language-text"><code>function example() {
  console.log(named)  // =&gt; undefined

  named()   // =&gt; TypeError named is not a function

  superPower()  // =&gt; ReferenceError superPower is not defined

  var named = function superPower () {
    console.log('Flying')
  }
}

function example() {
  console.log(named)  // =&gt; undefined

  named()   // =&gt; TypeError named is not a function

  var named = function named () {
    console.log('named')
  }
}
</code></pre></div></li></ul><h3 id="比较运算符-相等">比较运算符&amp;相等</h3><ul><li><p>使用 <code>===</code> 和 <code>!==</code> 而非 <code>==</code> 和 <code>!=</code>，eslint: <a href="https://eslint.org/docs/rules/eqeqeq.html" target="_blank" rel="noopener noreferrer">eqeqeq<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li><li><p>条件声明例如 <code>if</code> 会用 <code>ToBoolean</code> 这个抽象方法将表达式转成布尔值并遵循如下规则</p><ul><li><p><code>Objects</code> 等于 <code>true</code></p></li><li><p><code>Undefined</code> 等于 <code>false</code></p></li><li><p><code>Null</code> 等于 <code>false</code></p></li><li><p><code>Booleans</code> 等于 <code>布尔值</code></p></li><li><p><code>Numbers</code> 在 <code>+0</code>, <code>-0</code>, 或者 <code>NaN</code> 的情况下等于 <code>false</code>, 其他情况是 <code>true</code></p></li><li><div class="language- extra-class"><pre class="language-text"><code>Strings
</code></pre></div><p>为</p><div class="language- extra-class"><pre class="language-text"><code>''
</code></pre></div><p>时等于</p><div class="language- extra-class"><pre class="language-text"><code>false
</code></pre></div><p>, 否则是</p><div class="language- extra-class"><pre class="language-text"><code>true
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>if ([0] &amp;&amp; []) {
  // true
  // 数组(即使是空数组)也是对象，对象等于true
}
</code></pre></div></li></ul></li></ul><h3 id="分号">分号</h3><ul><li><p>我们遵循 <code>Standard</code> 的规范，不使用分号。</p><blockquote><p>关于应不应该使用分号的讨论有很多，本规范认为非必要的时候，应该不使用分号，好的 <code>JS</code> 程序员应该清楚场景下是一定要加分号的，相信你也是名好的开发者。</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>// bad
const test = 'good';
(function () {
  const str = 'hahaha';
})()

// good
const test = 'good'
;(() =&gt; {
  const str = 'hahaha'
})();
</code></pre></div></li></ul><h3 id="标准特性">标准特性</h3><p>为了代码的可移植性和兼容性，我们应该最大化的使用标准方法，例如优先使用 <code>string.charAt(3)</code> 而不是 <code>string[3]</code></p><h3 id="eval">eval()</h3><p>由于 <code>eval</code> 方法比较 <code>evil</code>，所以我们约定禁止使用该方法</p><h3 id="with">with() {}</h3><p>由于 <code>with</code> 方法会产生神奇的作用域，所以我们也是禁止使用该方法的</p><h3 id="修改内置对象的原型">修改内置对象的原型</h3><p>不要修改内置对象，如 <code>Object</code> 和 <code>Array</code></p><h2 id="typescript">Typescript</h2><p>1、组件的 props 要写清楚类型，function 回调需要精确到参数类型</p><p>2、对于接收可渲染类型的 props，不要只使用 string，应该使用 <code>React.ReactNode</code>，以便支持传入组件、dom、number、string等</p><p>3、Reducer State 使用规范：</p><div class="language- extra-class"><pre class="language-text"><code>export class State {
  cnt = new AsyncTuple&lt;number&gt;();
  projectEnName = '';
  projectCnName = '';
}

const initialState = new State();

function Reducer(state: State, action: Action): State {
  const { payload, type } = action;
  
  switch (type) {
    case Types.loading: {
      return ...
    }
  }
}
</code></pre></div><ol><li>combineReducers 加上注释:</li></ol><div class="language- extra-class"><pre class="language-text"><code>const reducer = combineReducers({
   /** 导航 */
   nav: NavReducer,
   /** 搜索  */
   search: SearchReducer
});
</code></pre></div><ol><li>全局的 State 和 GetState 类型:</li></ol><div class="language- extra-class"><pre class="language-text"><code>// connect
const mapStateToProps = (state?: IDEState, ownProp?: any): typeof initialState =&gt; ({
  ...state.assets.map
});

// thunk
(dispatch: any, getState: GetIDEState) =&gt; {
  ...
}
</code></pre></div><p><a href="https://typescript.bootcss.com/declaration-files/do-s-and-don-ts.html" target="_blank" rel="noopener noreferrer">官网规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h2 id="移动端优化">移动端优化</h2><h4 id="click-的-300ms-延迟响应">click 的 300ms 延迟响应</h4><p>click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，使用 FastClick</p><h4 id="快速回弹滚动">快速回弹滚动</h4><div class="language- extra-class"><pre class="language-text"><code>.element { 
		overflow: auto; /* auto | scroll */ 
		-webkit-overflow-scrolling: touch;
}
</code></pre></div><h4 id="设备检测">设备检测</h4><div class="language- extra-class"><pre class="language-text"><code>// 这段代码引用自：https://github.com/binnng/device.js

var WIN = window;
var LOC = WIN[&quot;location&quot;]; 
var NA = WIN.navigator; 
var UA = NA.userAgent.toLowerCase(); 
function test(needle) { 
	return needle.test(UA);
} 
var IsTouch = &quot;ontouchend&quot; in WIN; 
var IsAndroid = test(/android|htc/) || /linux/i.test(NA.platform + &quot;&quot;); 
var IsIPad = !IsAndroid &amp;&amp; test(/ipad/); 
var IsIPhone = !IsAndroid &amp;&amp; test(/ipod|iphone/); 
var IsIOS = IsIPad || IsIPhone; 
var IsWinPhone = test(/windows phone/); 
var IsWebapp = !!NA[&quot;standalone&quot;]; 
var IsXiaoMi = IsAndroid &amp;&amp; test(/mi\s+/);
var IsUC = test(/ucbrowser/); 21. var IsWeixin = test(/micromessenger/); 
var IsBaiduBrowser = test(/baidubrowser/); 
var IsChrome = !!WIN[&quot;chrome&quot;];
var IsBaiduBox = test(/baiduboxapp/);
var IsPC = !IsAndroid &amp;&amp; !IsIOS &amp;&amp; !IsWinPhone;
var IsHTC = IsAndroid &amp;&amp; test(/htc\s+/);
var IsBaiduWallet = test(/baiduwallet/);
</code></pre></div><h4 id="清除输入框内阴影">清除输入框内阴影</h4><div class="language- extra-class"><pre class="language-text"><code>input, 
textarea { 
	border: 0;
  -webkit-appearance: none; 
}
</code></pre></div><h4 id="电话号码识别">电话号码识别</h4><div class="language- extra-class"><pre class="language-text"><code> &lt;!-- 关闭电话号码识别： --&gt;
 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 
 
 &lt;!-- 开启电话功能： --&gt; 
 &lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt; 
 
 &lt;!-- 开启短信功能： --&gt; 
 &lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt;
</code></pre></div><h4 id="邮箱地址的识别">邮箱地址的识别</h4><div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 关闭邮箱地址识别： --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; 

&lt;!-- 开启邮件发送： --&gt; &lt;a mailto:&gt;mobile@gmail.com&quot;&gt;mobile@gmail.com&lt;/a&gt;
</code></pre></div><h4 id="指定-ios-的-safari-顶端状态条的样式">指定 iOS 的 safari 顶端状态条的样式</h4><div class="language- extra-class"><pre class="language-text"><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; 
&lt;!-- 可选default、black、black-translucent --&gt;
</code></pre></div><h2 id="react-jsx">React&amp;JSX</h2><h3 id="组件">组件</h3><p>1、公用组件写文档，<code>props</code> 和 <code>state</code> 必须加上中文说明</p><p>2、平台组件里所有的 <code>props</code> 提供验证 <code>propTypes</code></p><p>3、为权限控制，在小粒度的操作组件中加disabled的props</p><p>4、使用纯函数创建 React 组件时，不要使用箭头函数（因为它不能得到 displayName）</p><p>5、禁止出现 warning，一定要解决</p><p>6、禁用 <code>&lt;a&gt;</code> 默认跳转行为应该使用 <code>&lt;a href=&quot;javascript:;&quot; /&gt;</code>，不要使用 <code>href='#'</code></p><p>7、在做 <code>Form</code> 的时候不要使用 <code>&lt;Form onSubmit&gt;</code> 因为它是传统刷新页面式的提交。正确的做法是在 submit button 上绑定 <code>onClick</code> 手动处理</p><p>8、组件文件，命名使用 PascalCase，组件引用 PascalCase</p><h3 id="通用">通用</h3><p>1、render函数放在最后，顺序是propTypes, props和state的初始化, component初始化，其它方法</p><p>2、回调方法一率用on-, before-, after-开头，加一名词，比如<code>onSwitched</code>，component内事件，一率用 <code>handle-</code> 开头，加一名词</p><p>3、bool 类变量，开头只有三种，is，has，can</p><p>4、子传递回调最多两次，一般情况下也要避免回传两次</p><p>5、数据一般情况都是以Props传入，如频繁更新或特殊情况，如子模块依赖Model，使用State</p><p>6、生意参谋平台相关 url 不能写死，要从 <code>LinkUrl</code> 里读取。如果<code>LinkUrl</code>里没有，则添加到<code>LinkUrl</code></p><p>7、<code>a</code> 标签想禁用默认跳转形为时使用 <code>&lt;a javascript:void(0) /&gt;;</code> ，不要使用 <code>event.preventDefault()</code></p><p>8、定义ref 的名称， 要以ref 开头的驼峰; 如:  refGraphToolsCont</p><h2 id="vue">Vue</h2><p><a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener noreferrer">风格指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h2 id="git-仓库分支名规范">Git 仓库分支名规范</h2><ul><li>功能分支：  <code>feat/xxx</code></li><li>bugfix 分支：  <code>fix/xxx</code></li><li>tmp分支： <code>tmp/xxx</code></li><li>版本分支：v1.1.0</li></ul><h2 id="git-commit-建议">Git Commit 建议</h2><ul><li>除发布 commit 外，不要提交 <code>build</code> 或 <code>dist</code> 文件；</li><li>提交前一定要看一下都提交了哪些文件，可以使用 <code>git add [file_name]</code> 一个个添加文件，不要提交无用文件。</li></ul><p>完整的规范如下</p><div class="language- extra-class"><pre class="language-text"><code> * 代码提交基本格式为：&lt;type&gt;(scope?): &lt;subject&gt;
 * 冒号后面要留空格
 
type：
 * build: 改变了build工具 如 webpack
 * ci: 持续集成新增
 * chore: 构建过程或辅助工具的变动
 * feat: 新功能
 * docs: 文档改变
 * fix: 修复bug
 * perf: 性能优化
 * refactor: 某个已有功能重构
 * revert: 撤销上一次的 commit
 * style: 代码格式改变
 * test: 增加测试
 * anno: 增加注释
 * deps: 依赖更新
</code></pre></div></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/Weblog/assets/js/app.bc17a3fe.js" defer></script><script src="/Weblog/assets/js/100.b8573d34.js" defer></script>
  </body>
</html>
